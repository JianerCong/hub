** ethash
*** install and hi
**** install
#+begin_src bash
  cmake -S ethash-1.0.1 -B build-ethash
  cmake --build build-ethash/
  cmake --install build-ethash/ --prefix installed-ethash

  # cmake --install build-ethash/ --prefix installed-ethash
  # -- Install configuration: ""
  # -- Installing: /home/me/repo/installed-ethash/lib/libkeccak.a
  # -- Installing: /home/me/repo/installed-ethash/lib/libethash.a
  # -- Installing: /home/me/repo/installed-ethash/lib/libethash-global-context.a
  # -- Installing: /home/me/repo/installed-ethash/include
  # -- Installing: /home/me/repo/installed-ethash/include/ethash
  # -- Installing: /home/me/repo/installed-ethash/include/ethash/keccak.h
  # -- Installing: /home/me/repo/installed-ethash/include/ethash/global_context.hpp
  # -- Installing: /home/me/repo/installed-ethash/include/ethash/hash_types.hpp
  # -- Installing: /home/me/repo/installed-ethash/include/ethash/keccak.hpp
  # -- Installing: /home/me/repo/installed-ethash/include/ethash/hash_types.h
  # -- Installing: /home/me/repo/installed-ethash/include/ethash/version.h
  # -- Installing: /home/me/repo/installed-ethash/include/ethash/ethash.hpp
  # -- Installing: /home/me/repo/installed-ethash/include/ethash/global_context.h
  # -- Installing: /home/me/repo/installed-ethash/include/ethash/ethash.h
  # -- Installing: /home/me/repo/installed-ethash/lib/cmake/ethash/ethashTargets.cmake
  # -- Installing: /home/me/repo/installed-ethash/lib/cmake/ethash/ethashTargets-noconfig.cmake
  # -- Installing: /home/me/repo/installed-ethash/lib/cmake/ethash/ethashConfig.cmake
  # -- Installing: /home/me/repo/installed-ethash/lib/cmake/ethash/ethashConfigVersion.cmake

  # Check the targets
  cat /home/me/repo/installed-ethash/lib/cmake/ethash/ethashTargets.cmake | grep add_library

#+end_src
**** cmake
#+begin_src cmake
cmake_minimum_required(VERSION 3.21)

# include("cmake/HunterGate.cmake")
# HunterGate(
#   URL "https://github.com/cpp-pm/hunter/archive/v0.23.297.tar.gz"
#   SHA1 "3319fe6a3b08090df7df98dee75134d68e2ef5a3"
# )

project(hi VERSION 1.1)
set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

find_package(Boost REQUIRED COMPONENTS unit_test_framework)
# add the executable

set(ethash_DIR "/home/me/repo/installed-ethash/lib/cmake/ethash/")
find_package(ethash REQUIRED)     #do not explicitly specify the components

add_executable(main test.cpp)
target_link_libraries(main PUBLIC Boost::unit_test_framework ethash::ethash)
add_custom_target(run ALL main --log_level=all COMMENT "Runing App üê∏")
# add_custom_target(run ALL main --run_test=@aaa --log_level=all COMMENT "Runing App üê∏")


#+end_src
**** test
#+begin_src c++
  #define BOOST_TEST_MAIN
  #include <boost/test/unit_test.hpp>
  #include <ethash/keccak.hpp>
  #include <string>
  using std::string;
  #include <string_view>
  using std::string_view;


  BOOST_AUTO_TEST_CASE(test_ethash){
    string s = "baz(uint32,bool)";
    ethash::hash256 h = ethash::keccak256(reinterpret_cast<uint8_t*>(s.data()),
                                          s.size());

    string_view v{reinterpret_cast<const char*>(h.bytes),4};
    BOOST_CHECK_EQUAL(v,"\xcd\xcd\x77\xc0");

    // Got from --------------------------------------------------
    // from eth_hash.auto import keccak
    // s='baz(uint32,bool)'
    // b1 = bytes(s,'utf-8')
    // b = keccak(b1)
    // h = b.hex()
    // h[:8] # 'cdcd77c0' the first 4 bytes used as function selector
  }

  BOOST_AUTO_TEST_CASE(test_xor){
    uint8_t x{0xff};
    uint8_t y{0x0f};

    BOOST_CHECK_EQUAL(x^y,uint8_t{0xf0});
  }
#+end_src
** jsoncpp
*** install and hi
**** install
#+begin_src bash
  cmake -S jsoncpp-1.9.5/ -B build-jsoncpp \
        -DJSONCPP_WITH_TESTS=0 -DBUILD_SHARED_LIBS=0 \
        -DCMAKE_BUILD_TYPE=Release -DBUILD_OBJECT_LIBS=0
  cmake --build build-jsoncpp
  cmake --install build-jsoncpp --prefix installed-jsoncpp

#+end_src
**** cmake
#+begin_src cmake
cmake_minimum_required(VERSION 3.21)

# include("cmake/HunterGate.cmake")
# HunterGate(
#   URL "https://github.com/cpp-pm/hunter/archive/v0.23.297.tar.gz"
#   SHA1 "3319fe6a3b08090df7df98dee75134d68e2ef5a3"
# )

project(hi VERSION 1.1)
set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

find_package(Boost REQUIRED COMPONENTS unit_test_framework)
# add the executable

set(jsoncpp_DIR "/home/me/repo/installed-jsoncpp/lib/cmake/jsoncpp")
# hunter_add_package(jsoncpp)
find_package(jsoncpp CONFIG REQUIRED)

add_executable(main test.cpp)
target_link_libraries(main PUBLIC Boost::unit_test_framework JsonCpp::JsonCpp)
add_custom_target(run ALL main --log_level=all COMMENT "Runing App üê∏")
# add_custom_target(run ALL main --run_test=@aaa --log_level=all COMMENT "Runing App üê∏")

#+end_src
**** use
#+begin_src c++
#define BOOST_TEST_MAIN
#include <boost/test/unit_test.hpp>
#include <json/json.h>
#include <json/reader.h>
#include <json/writer.h>
using Json::Value;
using Json::CharReader;

#include <memory>
using std::unique_ptr;

#include <string_view>
using std::string_view;
#include <string>
using std::string;


BOOST_AUTO_TEST_CASE(trivial_parse) {
  string_view s = "{\"x\" : true}";
  unique_ptr<CharReader> r{Json::CharReaderBuilder().newCharReader()};

  Json::Value v;
  string err;
  bool ok = r->parse(s.data(),s.data() + s.size(),&v,&err);
  bool x = v["x"].asBool();

  BOOST_CHECK(ok);
  BOOST_CHECK_EQUAL(v.type(),Json::ValueType::objectValue);
  BOOST_CHECK_EQUAL(x,true);
}

BOOST_AUTO_TEST_CASE(parse_int_string_array) {
  string_view s = "{"
    "\"w\" : \"abc\","
    "\"x\" : true,"
    "\"y\" : [1,2,3],"
    "}";
  // CharReader* r = Json::CharReaderBuilder().newCharReader();
  unique_ptr<CharReader> r{Json::CharReaderBuilder().newCharReader()};
  Value v;
  string err;
  bool ok = r->parse(s.data(),s.data() + s.size(),&v,&err);
  BOOST_REQUIRE(ok);

  string w = v["w"].asString();
  Value y = v["y"];
  BOOST_REQUIRE_EQUAL(y.size(),3);
  uint64_t i = y[1].asUInt64();

  BOOST_CHECK_EQUAL(v.type(),Json::ValueType::objectValue);
  BOOST_CHECK_EQUAL(w,"abc");
  BOOST_CHECK_EQUAL(i,2);
}

BOOST_AUTO_TEST_CASE(parse_with_helper_func) {
  // I feel like r->parse() is alright
  string s = "{"
    "\"w\" : \"abc\","
    "}";
  auto b = Json::CharReaderBuilder();
  Value v; string err;
  auto s1 = std::istringstream(s);
  bool ok = Json::parseFromStream(b,s1,&v,&err);
  BOOST_REQUIRE(ok);

  string w = v["w"].asString();
  BOOST_CHECK_EQUAL(w,"abc");
}
BOOST_AUTO_TEST_CASE(parse_obj) {
  string_view s = "{"
    "\"x\" : true,"
    "\"y\" : {\"w\": 123},"
    "}";
  // CharReader* r = Json::CharReaderBuilder().newCharReader();
  unique_ptr<CharReader> r{Json::CharReaderBuilder().newCharReader()};
  Value v;

  string err;
  bool ok = r->parse(s.data(),s.data() + s.size(),&v,&err);
  BOOST_REQUIRE(ok);

  Value y = v["y"];
  BOOST_REQUIRE_EQUAL(y.type(),Json::ValueType::objectValue);

  BOOST_CHECK_EQUAL(y["w"].asUInt64(),123);
}

BOOST_AUTO_TEST_CASE(marshel_obj) {
  // For convenience, use `writeString()` with a specialized builder.
  Json::StreamWriterBuilder w;
  Value v;                      // default to empty object
  v["x"] = 1;
  std::string d = Json::writeString(w,v);
  BOOST_CHECK_EQUAL(d,"{\n"
                    "\t\"x\" : 1\n"
                    "}");
}

BOOST_AUTO_TEST_CASE(marshel_array) {
  // For convenience, use `writeString()` with a specialized builder.
  Json::StreamWriterBuilder w;
  w.settings_["indentation"] = "";
  Value v;                      // default to empty object
  v["x"].append(1);
  v["x"].append(2);
  v["x"].append(3);
  std::string d = Json::writeString(w,v);
  BOOST_CHECK_EQUAL(d,"{\"x\":[1,2,3]}");
}

BOOST_AUTO_TEST_CASE(marshel_obj_with_options) {
  Json::StreamWriterBuilder w;
  w.settings_["indentation"] = "";
  // empty indentation also omit newlines, so effectively makes it compact
  w.settings_["emitUTF8"] = true;
  Value v;                      // default to empty object
  v["x"] = 1;
  std::string d = Json::writeString(w,v);
  // StreamWriter* w = Json::StreamWriterBuilder().newStreamWriter();
  BOOST_CHECK_EQUAL(d,"{\"x\":1}");
}

BOOST_AUTO_TEST_CASE(iterate){
  Json::Value v(Json::objectValue);
  // Json::Value null_value; // null
  // Json::Value arr_value(Json::arrayValue); // []
  // Json::Value obj_value(Json::objectValue); // {}
  v["x"] = 1;
  v["y"] = "aaa";

  Json::Value::Members ks = v.getMemberNames();
  // ^^^^^^^^^^^^^^^^^^^^ Currently vector<string>
  BOOST_CHECK_EQUAL(ks.size(),2);

  BOOST_CHECK_EQUAL(ks[0],"x");
  BOOST_CHECK_EQUAL(ks[1],"y");
  BOOST_CHECK_EQUAL(v[ks[0]].asUInt64(),1);
  BOOST_CHECK_EQUAL(v[ks[1]].asString(),"aaa");

  BOOST_CHECK_EQUAL(v.size(),2);
  }
#+end_src
** EVMONE
*** Q/A
**** Why there're opt code PUSH32, PUSH3,...
Lower push will still push a 32-long value but with 0-zero padding.

*** install
#+begin_src bash
  # cmake -S evmone -B build-evmone -DEVMC_INSTALL=1 -DEVMC_TESTING=1 # TESTING builds everything
  # c
  tar zxf evmone-0.9.1-linux-x86_64.tar.gz --directory=evmone-0.9.1/

  git clone --recursive https://github.com/ethereum/evmone
  cmake -S evmone -B build-evmone -DEVMC_INSTALL=1 -DBUILD_SHARED_LIBS=0 # TESTING builds everything
  cmake --build build-evmone

  rm installed-evmone/ -rf
  cmake --install build-evmone --prefix installed-evmone
  # ./build-evmone/bin/evmc-unittests --gtest_list_tests
  # ./build-evmone/bin/evmc-unittests
  # ./build-evmone/bin/evmc-unittests --gtest_filter=example_vm.*

#+end_src
*** helloworld with headers
**** cpp
#+begin_src c++
#include <evmc/evmc.hpp>
#include <cstdio>

#define DEBUG
#ifdef DEBUG
#define P(...) printf(__VA_ARGS__)
#endif

int main(int argc, char *argv[]){
  // using namespace evmc;
  // uint8_t i = 0xff;
  // P("got value %x\n",i);

  evmc::bytes32 v1;
  for (int i = 0;i<32;i++){P("%x,",v1.bytes[i]);}
  P("Before ^\n");

  for (int i = 0;i<32;i++){v1.bytes[i] = 0xff;}

  for (int i = 0;i<32;i++){P("%x,",v1.bytes[i]);}
  P("After ^\n");
  return 0;
}

#+end_src
**** cmake
#+begin_src cmake
cmake_minimum_required(VERSION 3.21)
project(hi VERSION 1.1)

add_executable(main test.cpp)
# target_include_directories(main PUBLIC /home/me/repo/evmone/evmc/include/)
target_include_directories(main PUBLIC ../evmone/evmc/include/)
add_custom_target(run ALL main 1 COMMENT "Runing App üê∏")

include(CMakePrintHelpers)
cmake_print_properties(TARGETS main PROPERTIES INCLUDE_DIRECTORIES)

#+end_src
*** StorageValue
#+begin_src c++
#include <evmc/evmc.hpp>
#include <evmc/mocked_host.hpp>
#include <cstdio>

#define DEBUG
#ifdef DEBUG
#define P(...) printf(__VA_ARGS__)
#endif

int main(int argc, char *argv[]){
  using namespace evmc;
  bytes32 v1, v2;
  for (int i = 0;i<32;i++){v1.bytes[i] = 0xff;}

  StorageValue s{v1,v2,EVMC_ACCESS_COLD};
  P("Curent : ");
  for (int i = 0;i<32;i++) P("%x ",s.current.bytes[i]); puts("");
  P("Original : ");
  for (int i = 0;i<32;i++) P("%x ",s.original.bytes[i]); puts("");
  return 0;
}
// Curent : ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff 
// Original : 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 


#+end_src
*** opcode
+ ÊØîËæÉÈáçË¶ÅÁöÑÂ∞±ÊòØ f3 : RETURN
***** ‰æãÂ≠ê
#+begin_src c++
  7f #push32 val
  d0d1d2d3d4d5d6d7d8d9dadbdcdddedf
  e0e1e2e3e4e5e6e7e8e9eaebecedeeef

  60 #push1 0
  00

  52 #memstore(0,val)

  60 #push1 20
  20

  60 #push1 0
  00


  f3 #return Memory[00:00+20] ‚áí MemÈáåÁöÑ0Âà∞32bytes = val
#+end_src
*** full hello with evmone
**** cpp
#+begin_src cpp
#define BOOST_TEST_MAIN
#include <boost/test/unit_test.hpp>
#include <evmc/evmc.hpp>        // for evmc::VM
#include <evmone/evmone.h>      // for evmc_create_evmone

BOOST_AUTO_TEST_CASE(t1) {
  evmc::VM vm{evmc_create_evmone()};
  BOOST_CHECK_EQUAL(vm.name(),"evmone");
  BOOST_CHECK_NE(vm.name(),"evmtwo");
}
#+end_src
**** cmake
#+begin_src cmake
cmake_minimum_required(VERSION 3.21)

# initially
# > mkdir cmake
# > wget https://raw.githubusercontent.com/cpp-pm/gate/master/cmake/HunterGate.cmake -O cmake/HunterGate.cmake
include("cmake/HunterGate.cmake")
HunterGate(
  URL "https://github.com/cpp-pm/hunter/archive/v0.23.297.tar.gz"
  SHA1 "3319fe6a3b08090df7df98dee75134d68e2ef5a3"
)

project(hi VERSION 1.1)

find_package(Boost REQUIRED COMPONENTS unit_test_framework)

set(evmc_DIR "/home/me/repo/installed-evmone/lib/cmake/evmc/")
find_package(evmc REQUIRED)     #do not explicitly specify the components
                                #because the authors are lazy,they didin't set
                                #<pkg>_<compnent>_FOUND=1 for found components

## Now we have evmc::evmc , evmc_cpp
set(evmone_DIR "/home/me/repo/installed-evmone/lib/cmake/evmone/")
find_package(evmone REQUIRED)     #do not explicitly specify the components
## Now we have evmone::evmone


hunter_add_package(intx)
find_package(intx REQUIRED)     #do not explicitly specify the components
hunter_add_package(ethash)
find_package(ethash REQUIRED)     #do not explicitly specify the components

add_executable(main test.cpp)
target_link_libraries(main
  evmc::evmc_cpp
  evmone::evmone
  Boost::unit_test_framework
  intx::intx
  ethash::keccak
)
#  Âõ†‰∏∫ÊúâINTERFACE_LINK_LIBRARIES "evmc::evmc;intx::intx;\$<LINK_ONLY:ethash::keccak>",
# ÊâÄ‰ª•EVMONEË¶ÅÊ±Çintx,evmc,ethash::keccak


add_custom_target(run ALL main --log_level=all COMMENT "Runing App üê∏")

# cmake -S. -B build -DHUNTER_STATUS_DEBUG=ON -DCMAKE_BUILD_TYPE=Release
# cmake --build build --config Release

#+end_src
** Hunter
#+begin_src bash
  mkdir cmake
  wget https://raw.githubusercontent.com/cpp-pm/gate/master/cmake/HunterGate.cmake -O cmake/HunterGate.cmake
  
#+end_src
*** cmake
#+begin_src cmake
    cmake_minimum_required(VERSION 3.2)

  include("cmake/HunterGate.cmake")
  HunterGate(
      URL "https://github.com/cpp-pm/hunter/archive/v0.23.297.tar.gz"
      SHA1 "3319fe6a3b08090df7df98dee75134d68e2ef5a3"
  )

  project(Foo)

  hunter_add_package(Boost COMPONENTS regex system filesystem)
  find_package(Boost CONFIG REQUIRED regex system filesystem)

  add_executable(foo foo.cpp)
  target_link_libraries(foo PUBLIC Boost::regex Boost::system Boost::filesystem)
#+end_src
*** build
#+begin_src bash
cmake -S. -B_builds -DHUNTER_STATUS_DEBUG=ON -DCMAKE_BUILD_TYPE=Release
cmake --build _builds --config Release
#+end_src
** TBB
*** install
#+begin_src bash
  git clone https://github.com/oneapi-src/oneTBB.git
  cmake -S oneTBB-2021.9.0 -B build-oneTBB -DCMAKE_INSTALL_PREFIX=installed-oneTBB -DTBB_TEST=OFF
  cmake --build build-oneTBB
  # Install
  cmake --install build-oneTBB
  #-- Installing: /home/me/repo/installed-oneTBB/lib/cmake/TBB/TBBTargets.cmake
  # -- Installing: /home/me/repo/installed-oneTBB/lib/cmake/TBB/TBBConfig.cmake

  # what targets are installed?
  cat /home/me/repo/installed-oneTBB/lib/cmake/TBB/TBBTargets.cmake | grep add_library
#+end_src
*** hello world
**** cmake
#+begin_src cmake
cmake_minimum_required(VERSION 3.21)

project(hi VERSION 1.1)
set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

find_package(Boost REQUIRED COMPONENTS unit_test_framework)
set(TBB_DIR "/home/me/repo/installed-oneTBB/lib/cmake/TBB/")

find_package(TBB CONFIG REQUIRED)

# add the executable
add_executable(main test.cpp)
target_link_libraries(main PUBLIC Boost::unit_test_framework TBB::tbb)
add_custom_target(run ALL main --log_level=all COMMENT "Runing App üê∏")

#+end_src
**** c++
#+begin_src c++
#define BOOST_TEST_MAIN
#include <boost/test/unit_test.hpp>
#include <tbb/parallel_for.h>
#include <tbb/blocked_range.h>

using tbb::parallel_for;
using tbb::blocked_range;

BOOST_AUTO_TEST_CASE(test_1) {
  int o{0};
  auto f = [&](blocked_range<int> &r){
    for (int i = r.begin();i<r.end();++i)
      o+=i;
  };
  parallel_for(blocked_range<int>(1,4),f);

  BOOST_CHECK_EQUAL(o,1+2+3);
}

BOOST_AUTO_TEST_CASE(test_with_short_hand) {
  int o{0};
  parallel_for(size_t(0),size_t(4),size_t(1),[&](size_t i) {o+=i;});
  // for (i=0;i<3;i+=1;) o+=i
  BOOST_CHECK_EQUAL(o,1+2+3);
}

#+end_src
*** concurrent_map
#+begin_src c++
#define BOOST_TEST_MAIN
#include <boost/test/unit_test.hpp>
#include <functional>
#include <tbb/parallel_for.h>
#include <tbb/concurrent_hash_map.h>

using tbb::concurrent_hash_map;
using tbb::parallel_for;
struct C {
  static size_t hash(const int& i){
    std::hash<int> h;
    return h(i);
  }
  static bool equal(const int& x,const int& y){
    return x==y;
  }
};

BOOST_AUTO_TEST_CASE(test_1) {
  // accessor locks the key
  using M = concurrent_hash_map<int,int,C>;
  using S = size_t;
  M m;

  parallel_for(S(0),S(4),S(1),[&](S i){
    M::accessor a;              // a "write"lock for key a
    m.insert(a,(int) i);
    a->second = i*10;           // k=i,v=i*10
  });

  M::const_accessor a;              // read-only pointer
  bool found = m.find(a,2);         // read kv
  BOOST_CHECK(found);
  BOOST_CHECK_EQUAL(a->second,20);
  BOOST_CHECK_EQUAL(a->first,2);
}


#+end_src

** intx
*** bash [dirty way: copy the header]
#+begin_src bash
sudo mkdir  /usr/local/include/intx
sudo cp intx.hpp /usr/local/include/intx/ -v
#+end_src
*** install [polite way: follow the instrution]
#+begin_src bash
  mv ~/Downloads/intx-0.10.0.tar.gz .
  tar zxf intx-0.10.0.tar.gz
  cmake -S intx-0.10.0 -B build-intx -DINTX_TESTING=0
  cmake --build build-intx
  cmake --install build-intx --prefix installed-intx
#+end_src
*** tests
#+begin_src c++
#define BOOST_TEST_MAIN
#include <boost/test/unit_test.hpp>
#include <intx/intx.hpp>        // the whole package is header-only
#include <algorithm>


BOOST_AUTO_TEST_CASE(array_to_native_int){
  uint8_t a[3] = {0,0,1};
  // std::fill_n(a.bytes,20,0x0);
  uint64_t x = intx::be::load<uint64_t,3>(a);
  BOOST_CHECK_EQUAL(x,1);
}

BOOST_AUTO_TEST_CASE(struct_to_int){
  struct A {uint8_t bytes[8];};
  A a;
  std::fill_n(a.bytes,8,0x0);
  a.bytes[7] = 0x12;

  // a should have a .bytes field
  uint64_t x = intx::be::load<uint64_t,A>(a);
  // 8-byte int
  BOOST_CHECK_EQUAL(x,0x12);
}


BOOST_AUTO_TEST_CASE(array_to_int){
  uint8_t a[32];

  std::fill_n(a   ,30,0x0);
  std::fill_n(a+30,2,0xff);

  intx::uint256 x = intx::be::load<intx::uint256,32>(a);
  // 8-byte int
  BOOST_CHECK_EQUAL(int(x),0xffff);
}

#include <string_view>
BOOST_AUTO_TEST_CASE(int_to_array){    // int to array
  using namespace intx;

  constexpr auto size = sizeof(uint64_t);
  uint8_t data[size]{};
  std::string_view view{reinterpret_cast<const char*>(data), std::size(data)};

  be::store(data, uint64_t{0x0102030405060708});
  BOOST_CHECK_EQUAL(view,"\x01\x02\x03\x04\x05\x06\x07\x08");
}

BOOST_AUTO_TEST_CASE(int_to_small_array){
  intx::uint256 x{0xabcd};
  uint8_t a[2];
  std::string_view v{reinterpret_cast<const char*>(a), std::size(a)};
  intx::be::trunc<2,256>(a,x);

  BOOST_CHECK_EQUAL(v,"\xab\xcd"); // hex escape
  BOOST_CHECK_EQUAL(a[0],0xab);
  BOOST_CHECK_EQUAL(a[1],0xcd);
}

BOOST_AUTO_TEST_CASE(int_to_small_struct){
  struct A {uint8_t bytes[2];};
  intx::uint256 x{0xabcd};

  A a = intx::be::trunc<A,256>(x);
  std::string_view v{reinterpret_cast<const char*>(a.bytes), std::size(a.bytes)};

  BOOST_CHECK_EQUAL(v,"\xab\xcd"); // hex escape
  BOOST_CHECK_EQUAL(a.bytes[0],0xab);
  BOOST_CHECK_EQUAL(a.bytes[1],0xcd);
}
#+end_src
* End
# Local Variables:
# org-what-lang-is-for: "c++"
# End:
