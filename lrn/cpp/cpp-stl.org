** stl
*** count
#+begin_src c++
#define BOOST_TEST_MAIN
#include <boost/test/unit_test.hpp>
#include <vector>               // for std::begin
#include <algorithm>        // for count


struct bytes32 {
  uint8_t bytes[32];
};

using std::begin;
using std::end;


BOOST_AUTO_TEST_CASE(test_equal) {
  bytes32 b;
  BOOST_CHECK_EQUAL(sizeof(b),sizeof(b.bytes));
  BOOST_CHECK_EQUAL(sizeof(b),32);
  BOOST_CHECK_EQUAL(sizeof(b.bytes[0]),1);

  for (int i =0;i<32;i++) b.bytes[i]=0x0;
  BOOST_CHECK_EQUAL(std::count(begin(b.bytes),end(b.bytes),0),
                    int{sizeof(b)});
}

#+end_src
*** fill, fill_n, equal, copy_
#+begin_src c++
#define BOOST_TEST_MAIN
#include <boost/test/unit_test.hpp>
#include <iterator>               // for std::begin
#include <algorithm>            // for std::copy_n, equal, fill, fill_n


using std::begin;
using std::end;
using std::copy_n;
using std::equal;
using std::fill;
using std::fill_n;





BOOST_AUTO_TEST_CASE(test_copy_n) {
  int a[] = {1,2,3};
  int b[] = {0,0,0,0};

  copy_n(begin(a),2,begin(b));
  BOOST_CHECK_EQUAL(b[0],1);
  BOOST_CHECK_EQUAL(b[1],2);
  BOOST_CHECK_EQUAL(b[2],0);
}

BOOST_AUTO_TEST_CASE(t2) {
  int a[] = {1,2,3};
  int b[] = {0,0,0,0};
  int r[] = {1,2,0,0};

  copy_n(begin(a),2,begin(b));
  BOOST_CHECK(equal(begin(r), end(r),begin(b)));
}


BOOST_AUTO_TEST_CASE(test_fill_bytes) {
  uint8_t a[4];fill(begin(a), end(a), 0xff);
  uint8_t b[4] = {0,0,0,0};
  uint8_t r[] = {0,0,0,0}; fill_n(begin(r)+1,2,0xff); // 0,ff,ff,0

  copy_n(begin(a),2,begin(b)+1);
  BOOST_CHECK(equal(begin(r), end(r),begin(b)));
}

#+end_src
*** weak_ptr
#+begin_src c++
#define BOOST_TEST_MAIN
#include <boost/test/unit_test.hpp>
#include <iostream>
#include <memory>

std::weak_ptr<int> p;
using std::shared_ptr;

BOOST_AUTO_TEST_CASE(t1) {
  {
    auto p1 = std::make_shared<int>(123);
    p = p1;
    BOOST_CHECK_EQUAL(p.use_count(),1);
    // how many pointers point to this
    shared_ptr<int> p2 = p.lock();
    BOOST_CHECK(p2);
    BOOST_CHECK_EQUAL(*p2,123);
  }
  // Now p1 is gone
  BOOST_CHECK_EQUAL(p.use_count(),0);
  shared_ptr<int> p2 = p.lock();
  BOOST_CHECK(!p2);
  BOOST_CHECK(p.expired());
}

#+end_src

*** basic_string
Defined in header <string>
#+begin_src c++
#define BOOST_TEST_MAIN
#include <boost/test/unit_test.hpp>
#include <string>

using bytes = std::basic_string<uint8_t>;

BOOST_AUTO_TEST_CASE(test_1) {
  bytes s{0,1,2,3};

  BOOST_CHECK_EQUAL(s[0],0);
  BOOST_CHECK_NE(s[2],1);
  BOOST_CHECK_EQUAL(&*(s.begin() + 1), &*s.begin() + 1);
  // *& converts iterator to pointer
  BOOST_CHECK_EQUAL(s.data(),&*s.begin());

  // pointer and array class
  BOOST_CHECK_EQUAL(2,s.data()[2]);
  BOOST_CHECK_EQUAL(s.data() + 2,&(s.data()[2]));
  BOOST_CHECK_EQUAL(&s[2],s.data() + 2);

} // BOOST_AUTO_TEST_CASE(test_no_1)

#+end_src
*** check equal
#+begin_src c++
#define BOOST_TEST_MAIN
#include <boost/test/unit_test.hpp>
#include <string>
#include <bits/stdc++.h>


using bytes = std::basic_string<uint8_t>;

BOOST_AUTO_TEST_CASE(test_1) {
  bytes s{};
  s.reserve(32);
  BOOST_CHECK_EQUAL(std::count(s.begin(),s.end(),0),s.size());
}

BOOST_AUTO_TEST_CASE(test_2) {
  bytes s{1,2,2,3};
  BOOST_CHECK_EQUAL(std::count(s.begin(),s.end(),2),2);
}

BOOST_AUTO_TEST_CASE(test_equal) {
  bytes s{1,2,3};
  bytes s2{1,2,3};
  BOOST_CHECK(std::equal(s.begin(),s.end(),s2.begin()));
}

#+end_src
*** std::optional
#+begin_src c++
#define BOOST_TEST_MAIN
#include <boost/test/unit_test.hpp>
#include <string>
#include <optional>


using std::string;
std::optional<string> f(bool b) {
  if (b) return "123";
  return {};
}

BOOST_AUTO_TEST_CASE(test_1) {
  auto x = f(true);
  auto y = f(false);

  BOOST_CHECK(x);
  BOOST_CHECK_EQUAL(x.value(),string("123"));
  BOOST_CHECK_EQUAL(*x,x.value());

  BOOST_CHECK(!y);
  BOOST_CHECK_EQUAL(y.value_or("456"),string("456"));
}

#+end_src
*** std::function
#+begin_src c++
#define BOOST_TEST_MAIN
#include <boost/test/unit_test.hpp>
#include <functional>

using std::function;

int f(){return 123;}
int f1(int i){return i;}

struct f2 { //callable object
  int i = 456;
  int operator()(void) const{return this->i;}
};


BOOST_AUTO_TEST_CASE(test_1) {
  function<int(void)> x = f;
  function<int(void)> x1 = std::bind(f1,234);
  function<int(void)> x2 = [](){return 345;}; // store lambda
  function<int(void)> x3 = f2();

  BOOST_CHECK_EQUAL(123,x());
  BOOST_CHECK_EQUAL(234,x1());
  BOOST_CHECK_EQUAL(345,x2());
  BOOST_CHECK_EQUAL(456,x3());
}

#+end_src
*** hash
#+begin_src c++
#define BOOST_TEST_MAIN
#include <boost/test/unit_test.hpp>
#include <functional>           // for hash
#include <string>

using std::hash;
using std::string;


BOOST_AUTO_TEST_CASE(test_1) {
  hash<string> H;
  string s{"aaa"},s1{"bbb"},s2{"aaa"};
  size_t h{H(s)}, h1{H(s1)},h2{H(s2)};

  BOOST_CHECK_NE(h,h1);
  BOOST_CHECK_EQUAL(h,h2);
}
#+end_src
*** std::priority_queue
#+begin_src c++
#define BOOST_TEST_MAIN
#include <boost/test/unit_test.hpp>
#include <functional>           // std::greater
#include <queue>
#include <vector>

#include <algorithm>
#include <random>


using std::priority_queue;
using std::vector;
using std::greater;
using std::less;


BOOST_AUTO_TEST_CASE(test_std_greater) {
  greater<int> g;               // a function object
  less<int> l;               // a function object
  BOOST_CHECK(g(2,1));
  BOOST_CHECK(!g(1,2));
  BOOST_CHECK(l(1,2));
}

BOOST_AUTO_TEST_CASE(test_1) {
  priority_queue<int,vector<int>,less<int>> q;

  // a random vector
  vector<int> v{1,3,2};
  // std::random_device rd;
  // std::mt19937 g(rd());
  // std::shuffle(v.begin(),v.end(),g);

  for (auto i : v){
    q.push(i);                  // sorted internally
  }
  BOOST_CHECK_EQUAL(q.top(),3); q.pop();
  BOOST_CHECK_EQUAL(q.top(),2); q.pop();
  BOOST_CHECK_EQUAL(q.top(),1);
}

#+end_src

*** Vector
**** init
#+begin_src c++
// CPP program to initialize a vector like
// an array.
#include <iostream>
#include <vector>
using namespace std;

int main()
{
	vector<int> vect{ 10, 20, 30 };

	for (int x : vect)
		cout << x << " ";

	return 0;
}

#+end_src
**** erase
#+BEGIN_SRC c++
// erasing from vector

#include <iostream>
#include <vector>
using std::cout;

#define SHOW std::cout << "myvector contains:"; \
  for (unsigned i=0; i<myvector.size(); ++i)    \
    std::cout << ' ' << myvector[i];            \
  std::cout << '\n'

int main ()
{
  std::vector<int> myvector;

  // set some values (from 1 to 10)
  for (int i=1; i<=10; i++) myvector.push_back(i);
  SHOW;

  cout << "erase the 6th element: \n";
  myvector.erase (myvector.begin()+5);
  SHOW;

  cout << "erase the first 3 elements: \n";
  myvector.erase (myvector.begin(),myvector.begin()+3);
  SHOW;


  return 0;
}

#+END_SRC
**** toString
#+begin_src c++

#ifdef _WIN32
#include <Windows.h>
#else
#include <unistd.h>
#endif

#include <cstdio>
#include <iostream>
#include <string>
#include <stack>
#include <vector>

using std::string;
using std::vector;
using std::cout;


// convert to vector to string
#include <sstream>
string v2s(vector<int> vec){
  // the vector-to-string
  std::stringstream ss;
  for(int i =0;i<vec.size();i++)
    { if(i != 0)
        { ss<<", ";
        }
      ss<< vec[i];
    }
  return ss.str();
}

#include <algorithm>            // for std::reverse
using std::reverse;
class Solution {
public:
  void nextPermutation(vector<int>& nums) {
    int L = nums.size();
    for (int i=L-2;i>-1;i--){
      if (nums[i] < nums[i+1]){
        int j = i + 1;

        while (j < (L - 1) && (nums[j+1] > nums[i])){
          j++;
        }

        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;


        // Reverse the tail-values
        // j = 1;
        // while((L - j) - (i+j) > 0){
        //   temp = nums[i+j];
        //   nums[i+j] = nums[L-j];
        //   nums[L-j] = temp;
        //   j++;
        // }
        reverse(nums.begin()+i+1, nums.end());

        return;
      }
    }

    reverse(nums.begin(),nums.end());
  }
};

int main(int argc, char *argv[]){
  Solution S;

  vector<int> nums{3,2,1};
  vector<int> nums2{1,2,3};

  S.nextPermutation(nums);
  printf("Should be %s \n it's %s \n", v2s(nums).c_str(), v2s(nums2).c_str());


  return 0;
}

#+end_src
**** iterator and distance
#+begin_src c++
  #include <cstdio>
  #include <vector>

  using std::vector;

  int main(){
    vector<int> v({1,2,3});

    auto p1 = v.begin();
    auto p2 = v.end();
    printf("*p1 is %d\n",*p1);//1
    printf("*(p2 - 1) is %d\n",*(p2 - 1)); // 3
    // Note: long int
    printf("*(p2 - p1) is %ld\n",p2 - p1); // 3
  }

#+end_src
**** find
#+begin_src c++
// CPP program to illustrate
// std::find
// CPP program to illustrate
// std::find
#include<bits/stdc++.h>

int main ()
{
	std::vector<int> vec { 10, 20, 30, 40 };
	// Element to be searched
	int ser = 30;

	// std::find function call
	std::vector<int>::iterator it =  std::find (vec.begin(), vec.end(), ser);
	if (it != vec.end())
    {
      std::cout << "Element " << ser <<" found at position : " ;
      std::cout << it - vec.begin() << " (counting from zero) \n" ;
    }
	else
		std::cout << "Element not found.\n\n";

	return 0;
}
// Output: 
// Original vector : 10 20 30 40
// Element 30 found at position : 2 (counting from zero)

#+end_src
*** List
**** basic
#+begin_src c++
#include <algorithm>
#include <iostream>
#include <list>
 
int main()
{
  // Create a list containing integers
  std::list<int> l = { 7, 5, 16, 8 };
 
  // Add an integer to the front of the list
  l.push_front(25);
  // Add an integer to the back of the list
  l.push_back(13);
 
  // Insert an integer before 16 by searching
  auto it = std::find(l.begin(), l.end(), 16);
  if (it != l.end()) {
    l.insert(it, 42);
  }
 
  // Print out the list
  std::cout << "l = { ";
  for (int n : l) {
    std::cout << n << ", ";
  }
  std::cout << "};\n";
}

#+end_src
**** random access
#+BEGIN_SRC c++
// list::begin
#include <iostream>
#include <list>

int main ()
{
  int myints[] = {75,23,65,42,13};
  std::list<int> mylist (myints,myints+5);

  std::cout << "mylist contains:";
  for (std::list<int>::iterator it=mylist.begin(); it != mylist.end(); ++it)
    std::cout << ' ' << *it;

  std::cout << '\n';

  return 0;
}
#+END_SRC
*** map
**** basic
   #+begin_src c++
/**
 * @file umap.cpp
 * @author Jianer Cong
 * @brief unordered map basic
 */

#include <unordered_map>
#include <iostream>

using std::cout;
using std::unordered_map;
using std::endl;


typedef unordered_map<int,const char*> umap;

int main(int argc, char *argv[]){
  umap m = {
            { 1 , "one"},
            {2, "two"}
  };

  cout << "Map contents are\n";
  for (const auto& [k, v] : m){
    cout << "Key " << k << " Value " << v << endl;
  }

  // Insert some value
  m.insert({3,"three"});
  m.insert({
            {4,"four"}, {5,"five"}
    });

  m.emplace(4,"NO");
  // Will not insert, since already exits/
  m.emplace(6,"six");

  cout << "Now the contents are:\n";
  for (const auto& p : m){
    cout << "\t"<< p.first << " : " << p.second << endl;
  }

  cout << "After erase one:\n";
  m.erase(1);

  for (const auto& p : m){
    cout << "\t"<< p.first << " : " << p.second << endl;
  }
  return 0;
  }

   #+end_src
**** caveat: [] access create member
#+begin_src c++
#define BOOST_TEST_MAIN
#include <boost/test/unit_test.hpp>
#include <unordered_map>

using std::unordered_map;
struct A {int a;};
BOOST_AUTO_TEST_CASE(test_1) {
  unordered_map<int,A> m;
  m[1].a = 123;                 // a new A is created
  BOOST_CHECK_EQUAL(m[1].a, 123);
} // BOOST_AUTO_TEST_CASE(test_no_1)

#+end_src
*** time
#+begin_src c++
#define BOOST_TEST_MAIN
#include <boost/test/unit_test.hpp>
#include <chrono>
#include <thread>


using namespace std::chrono;
BOOST_AUTO_TEST_CASE(test_1) {
  milliseconds m{1000};         // 1 sec
  m *= 2;
  BOOST_CHECK_EQUAL(m.count(),2000);
}

BOOST_AUTO_TEST_CASE(test_convert_to_sec) {
  milliseconds m{1000};         // 1 sec
  int sec = m.count() * milliseconds::period::num /
    milliseconds::period::den;
  BOOST_CHECK_EQUAL(sec,1);
}

BOOST_AUTO_TEST_CASE(test_time_sth) {
  time_point<system_clock> start, end;
  start = system_clock::now();

  using namespace std::chrono_literals;
  std::this_thread::sleep_for(3000ms); // sleep for 3sec

  end = system_clock::now();
  duration<double> elapsed_seconds = end - start;
  double s = elapsed_seconds.count();

  BOOST_CHECK(s > 2 && s < 4);  // slept for 3sec
}

// using tbb::parallel_for;
// using tbb::blocked_range;
// #include <tbb/parallel_for.h>
// #include <tbb/blocked_range.h>

#+end_src
*** sleep
#+begin_src c++
#include <iostream>
#include <chrono>
#include <thread>
 
int main()
{
    using namespace std::chrono_literals;
 
    std::cout << "Hello waiter\n" << std::flush;
 
    const auto start = std::chrono::high_resolution_clock::now();
    std::this_thread::sleep_for(2000ms);
    const auto end = std::chrono::high_resolution_clock::now();
    const std::chrono::duration<double, std::milli> elapsed = end - start;
 
    std::cout << "Waited " << elapsed << '\n';
}
#+end_src
*** structure binding
#+begin_src c++

#include <bits/stdc++.h>
using namespace std;
  
struct Point
{
    int x;
    int y;
};
  
// Driver code
int main( )
{
    Point p = { 1,2 };
      
    // Structure binding
    auto[ x_coord, y_coord ] = p;
      
    cout << "X Coordinate : " << x_coord << endl;
    cout << "Y Coordinate : " << y_coord << endl;
      
    return 0;
}
#+end_src
*** tuple and structure binding
#+begin_src c++

#include<tuple> // for tuple
using std::tuple;
using std::make_tuple;
tuple<int,string_view> f(){
  return make_tuple(123,"abc");
}
BOOST_AUTO_TEST_CASE(binding){
  auto [x,y] = f();
  BOOST_CHECK_EQUAL(x,123);
  BOOST_CHECK_EQUAL(y,"abc");
}

#+end_src
*** thread
**** id
#+begin_src c++
13   std::string id() {
14      std::ostringstream out;
15      out << std::this_thread::get_id();
16      return out.str();
17   }
#+end_src

* End
# Local Variables:
# org-what-lang-is-for: "c++"
# End:
