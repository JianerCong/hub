** stl
*** filesystem C++17
#+begin_src c++
  #define BOOST_TEST_MAIN
  #include <boost/test/unit_test.hpp>
  #include <filesystem>
  #include <string>
  #include <string_view>
  using std::string_view;
  using std::string;


  using std::filesystem::path;
  using std::filesystem::current_path;
  namespace fs = std::filesystem;

  #ifdef _WIN32
  #else
  // Unix-only test
  BOOST_AUTO_TEST_CASE(test_path){
    path p = "/tmp/hi.txt"; // portable format
    // fs::path p2 = "C:\\users\\abcdef\\AppData\\Local\\Temp\\"; // native format
    // fs::path p3 = U"D:/猫.txt"; // UTF-32 string
    // fs::path p4 = u8"~/狗.txt"; // UTF-8 string
    path f = p.filename();

    BOOST_CHECK_EQUAL(string(p),"/tmp/hi.txt");
    BOOST_CHECK_EQUAL(string(path("/tmp/hi.txt").filename()),"hi.txt");
    BOOST_CHECK_EQUAL(string(path("/tmp/hi").filename()),"hi");
    BOOST_CHECK_EQUAL(string(path("/tmp/").filename()),"");
    BOOST_CHECK_EQUAL(string(path("/tmp/hi.txt").parent_path()),"/tmp");
    BOOST_CHECK(path("").empty());
    // Current path
    // BOOST_CHECK_EQUAL(string(current_path()),"/home/me/repo/hi2/build");
  }
  #endif

  BOOST_AUTO_TEST_CASE(create_check_remove_empty_dir){
    path p = "/tmp/dir1"; // portable format

    BOOST_REQUIRE(fs::create_directories(p));
    BOOST_CHECK(fs::exists(p));

    // remove empty dir
    BOOST_REQUIRE(fs::remove(p));
    BOOST_CHECK(!fs::exists(p));
  }

  BOOST_AUTO_TEST_CASE(tmp_remove_nonempty_dir){
    fs::path tmp = std::filesystem::temp_directory_path();
    BOOST_REQUIRE(fs::create_directories(tmp / "aaa/bbb"));
    BOOST_CHECK(fs::exists(tmp / "aaa"));

    // remove recursively
    std::uintmax_t n = fs::remove_all(tmp / "aaa");

    BOOST_CHECK(!fs::exists(tmp / "aaa"));
    BOOST_CHECK_EQUAL(string(tmp),"/tmp");
    BOOST_CHECK_EQUAL(n,2);
  }

  #include <fstream>
  using std::ofstream;
  BOOST_AUTO_TEST_CASE(create_write_size_delete_file){
    path p{fs::temp_directory_path() / "hi.bin"};
    if (fs::exists(p)) fs::remove(p);

    ofstream(p).put('\xff').flush();
    // For unformatted, use:
    // (ofstream(p) << '\xff').flush();

    BOOST_CHECK_EQUAL(fs::file_size(p),1);
    BOOST_REQUIRE(fs::remove(p));
  }

  BOOST_AUTO_TEST_CASE(remove_nonempty_folder){
    fs::path tmp = std::filesystem::temp_directory_path();
    BOOST_REQUIRE(fs::create_directories(tmp / "aaa"));

    path p{tmp / "aaa/hi.bin"};

    (ofstream(p) << "abc").flush();
    // For unformatted, use:
    // ofstream(p).write("abc").flush();

    BOOST_CHECK_EQUAL(fs::file_size(p),3);
    // Cannot size a dir.
    BOOST_CHECK_THROW(fs::file_size(tmp / "aaa"),fs::filesystem_error);
    BOOST_REQUIRE(fs::remove_all(tmp / "aaa"));
  }

  BOOST_AUTO_TEST_CASE(move_folder){
    fs::path tmp = std::filesystem::temp_directory_path();
    path p1{tmp / "p1"};
    path p2{tmp / "p2"};

    if (fs::exists(p1)) fs::remove_all(p1);
    if (fs::exists(p2)) fs::remove_all(p2);

    fs::create_directories(p1);
    BOOST_REQUIRE(fs::exists(p1));
    BOOST_REQUIRE(!fs::exists(p2));

    // move the folder
    fs::rename(p1,p2);

    // Now p2 exists, p1 dosen't
    BOOST_REQUIRE(!fs::exists(p1));
    BOOST_REQUIRE(fs::exists(p2));

    // remove dir
    fs::remove_all(p2);
  }

  BOOST_AUTO_TEST_CASE(move_file){
    fs::path tmp = fs::temp_directory_path();
    path f1{tmp / "f1.txt"};
    path f2{tmp / "f2.txt"};

    if (fs::exists(f1)) fs::remove(f1);
    if (fs::exists(f2)) fs::remove(f2);

    ofstream(f1).put('a').flush();
    BOOST_REQUIRE(fs::exists(f1));
    BOOST_REQUIRE(!fs::exists(f2));
    BOOST_CHECK_EQUAL(fs::file_size(f1),1);

    // move the file
    fs::rename(f1,f2);

    // Now f2 exists, f1 dosen't
    BOOST_REQUIRE(!fs::exists(f1));
    BOOST_REQUIRE(fs::exists(f2));
    BOOST_CHECK_EQUAL(fs::file_size(f2),1);

    // remove dir
    fs::remove(f2);
    BOOST_REQUIRE(!fs::exists(f2));
  }


  BOOST_AUTO_TEST_CASE(copy){
      fs::path s = fs::temp_directory_path() / "sandbox";

      fs::create_directories(s / "d1");
      ofstream(s / "d1/f1.txt").put('a').flush();

      const auto copyOptions =
        fs::copy_options::update_existing
       // Replace the existing file only if it is older than the file being
        // copied
        | fs::copy_options::recursive;
      // Recursively copy subdirectories and their content

      std::error_code err;
      // copy dir recursively
      fs::copy(s / "d1",
               s / "d2",
               copyOptions,
               err);

      BOOST_REQUIRE(!bool(err));
      BOOST_CHECK(fs::exists(s / "d2"));
      BOOST_CHECK(fs::exists(s / "d2/f1.txt"));
      BOOST_CHECK(fs::exists(s / "d1"));
      BOOST_CHECK(fs::exists(s / "d1/f1.txt"));
      BOOST_CHECK_EQUAL(fs::file_size(s / "d2/f1.txt"),1);
      BOOST_CHECK_EQUAL(fs::file_size(s / "d1/f1.txt"),1);

      fs::remove_all(s);
  }
#+end_src
*** count
#+begin_src c++
#define BOOST_TEST_MAIN
#include <boost/test/unit_test.hpp>
#include <vector>               // for std::begin
#include <algorithm>        // for count


struct bytes32 {
  uint8_t bytes[32];
};

using std::begin;
using std::end;


BOOST_AUTO_TEST_CASE(test_equal) {
  bytes32 b;
  BOOST_CHECK_EQUAL(sizeof(b),sizeof(b.bytes));
  BOOST_CHECK_EQUAL(sizeof(b),32);
  BOOST_CHECK_EQUAL(sizeof(b.bytes[0]),1);

  for (int i =0;i<32;i++) b.bytes[i]=0x0;
  BOOST_CHECK_EQUAL(std::count(begin(b.bytes),end(b.bytes),0),
                    int{sizeof(b)});
}

#+end_src
*** fill, fill_n, equal, copy_
#+begin_src c++
#define BOOST_TEST_MAIN
#include <boost/test/unit_test.hpp>
#include <iterator>               // for std::begin
#include <algorithm>            // for std::copy_n, equal, fill, fill_n


using std::begin;
using std::end;
using std::copy_n;
using std::equal;
using std::fill;
using std::fill_n;





BOOST_AUTO_TEST_CASE(test_copy_n) {
  int a[] = {1,2,3};
  int b[] = {0,0,0,0};

  copy_n(begin(a),2,begin(b));
  BOOST_CHECK_EQUAL(b[0],1);
  BOOST_CHECK_EQUAL(b[1],2);
  BOOST_CHECK_EQUAL(b[2],0);
}

BOOST_AUTO_TEST_CASE(t2) {
  int a[] = {1,2,3};
  int b[] = {0,0,0,0};
  int r[] = {1,2,0,0};

  copy_n(begin(a),2,begin(b));
  BOOST_CHECK(equal(begin(r), end(r),begin(b)));
}


BOOST_AUTO_TEST_CASE(test_fill_bytes) {
  uint8_t a[4];fill(begin(a), end(a), 0xff);
  uint8_t b[4] = {0,0,0,0};
  uint8_t r[] = {0,0,0,0}; fill_n(begin(r)+1,2,0xff); // 0,ff,ff,0

  copy_n(begin(a),2,begin(b)+1);
  BOOST_CHECK(equal(begin(r), end(r),begin(b)));
}

#+end_src
*** weak_ptr
#+begin_src c++
#define BOOST_TEST_MAIN
#include <boost/test/unit_test.hpp>
#include <iostream>
#include <memory>

std::weak_ptr<int> p;
using std::shared_ptr;

BOOST_AUTO_TEST_CASE(t1) {
  {
    auto p1 = std::make_shared<int>(123);
    p = p1;
    BOOST_CHECK_EQUAL(p.use_count(),1);
    // how many pointers point to this
    shared_ptr<int> p2 = p.lock();
    BOOST_CHECK(p2);
    BOOST_CHECK_EQUAL(*p2,123);
  }
  // Now p1 is gone
  BOOST_CHECK_EQUAL(p.use_count(),0);
  shared_ptr<int> p2 = p.lock();
  BOOST_CHECK(!p2);
  BOOST_CHECK(p.expired());
}

#+end_src
*** unique_ptr
#+begin_src c++
#define BOOST_TEST_MAIN
#include <boost/test/unit_test.hpp>
#include <memory>

using std::unique_ptr;
using std::make_unique;

int x=0;
struct A {A() {x++;} ~A() {x++;}};
BOOST_AUTO_TEST_CASE(parse_obj) {
  {
    unique_ptr<A> p = make_unique<A>();
  }
  BOOST_CHECK_EQUAL(x,2);
}

#+end_src

*** basic_string
Defined in header <string>
#+begin_src c++
#define BOOST_TEST_MAIN
#include <boost/test/unit_test.hpp>
#include <string>

using bytes = std::basic_string<uint8_t>;

BOOST_AUTO_TEST_CASE(test_1) {
  bytes s{0,1,2,3};

  BOOST_CHECK_EQUAL(s[0],0);
  BOOST_CHECK_NE(s[2],1);
  BOOST_CHECK_EQUAL(&*(s.begin() + 1), &*s.begin() + 1);
  // *& converts iterator to pointer
  BOOST_CHECK_EQUAL(s.data(),&*s.begin());

  // pointer and array class
  BOOST_CHECK_EQUAL(2,s.data()[2]);
  BOOST_CHECK_EQUAL(s.data() + 2,&(s.data()[2]));
  BOOST_CHECK_EQUAL(&s[2],s.data() + 2);

} // BOOST_AUTO_TEST_CASE(test_no_1)

#+end_src
*** ostream, osstream/istringstream,...
**** to string
#+begin_src c++
  #define BOOST_TEST_MAIN
  #include <boost/test/unit_test.hpp>
  #include <iostream>
  #include <string>
  using std::string;


  BOOST_AUTO_TEST_CASE(parse_obj) {
    std::ostringstream b;
    b << 123;
    string s = b.str();
    BOOST_CHECK_EQUAL(s,"123");
  }

  #include <sstream>
  BOOST_AUTO_TEST_CASE(serl_obj) {
    std::istringstream s(string("1 2 3"));
    int n;
    s >> n;
    BOOST_CHECK_EQUAL(n,1);
  }
#+end_src
**** class hierarchy
+ ios_base
  + basic_ios
    + basic_ostream
    + ostream = basic_ostream<char>
      + basic_ostringstream
      + ostringstream = basic_ostringstream<char>
*** check equal
#+begin_src c++
#define BOOST_TEST_MAIN
#include <boost/test/unit_test.hpp>
#include <string>
#include <bits/stdc++.h>


using bytes = std::basic_string<uint8_t>;

BOOST_AUTO_TEST_CASE(test_1) {
  bytes s{};
  s.reserve(32);
  BOOST_CHECK_EQUAL(std::count(s.begin(),s.end(),0),s.size());
}

BOOST_AUTO_TEST_CASE(test_2) {
  bytes s{1,2,2,3};
  BOOST_CHECK_EQUAL(std::count(s.begin(),s.end(),2),2);
}

BOOST_AUTO_TEST_CASE(test_equal) {
  bytes s{1,2,3};
  bytes s2{1,2,3};
  BOOST_CHECK(std::equal(s.begin(),s.end(),s2.begin()));
}

#+end_src
*** std::optional
#+begin_src c++
#define BOOST_TEST_MAIN
#include <boost/test/unit_test.hpp>
#include <string>
#include <optional>


using std::string;
std::optional<string> f(bool b) {
  if (b) return "123";
  return {};
}

BOOST_AUTO_TEST_CASE(test_1) {
  auto x = f(true);
  auto y = f(false);

  BOOST_CHECK(x);
  BOOST_CHECK_EQUAL(x.value(),string("123"));
  BOOST_CHECK_EQUAL(*x,x.value());

  BOOST_CHECK(!y);
  BOOST_CHECK_EQUAL(y.value_or("456"),string("456"));
}

#+end_src
*** std::function
#+begin_src c++
#define BOOST_TEST_MAIN
#include <boost/test/unit_test.hpp>
#include <functional>

using std::function;

int f(){return 123;}
int f1(int i){return i;}

struct f2 { //callable object
  int i = 456;
  int operator()(void) const{return this->i;}
};


BOOST_AUTO_TEST_CASE(test_1) {
  function<int(void)> x = f;
  function<int(void)> x1 = std::bind(f1,234);
  function<int(void)> x2 = [](){return 345;}; // store lambda
  function<int(void)> x3 = f2();

  BOOST_CHECK_EQUAL(123,x());
  BOOST_CHECK_EQUAL(234,x1());
  BOOST_CHECK_EQUAL(345,x2());
  BOOST_CHECK_EQUAL(456,x3());
}

#+end_src
*** hash
#+begin_src c++
#define BOOST_TEST_MAIN
#include <boost/test/unit_test.hpp>
#include <functional>           // for hash
#include <string>

using std::hash;
using std::string;


BOOST_AUTO_TEST_CASE(test_1) {
  hash<string> H;
  string s{"aaa"},s1{"bbb"},s2{"aaa"};
  size_t h{H(s)}, h1{H(s1)},h2{H(s2)};

  BOOST_CHECK_NE(h,h1);
  BOOST_CHECK_EQUAL(h,h2);
}
#+end_src
*** std::priority_queue
#+begin_src c++
#define BOOST_TEST_MAIN
#include <boost/test/unit_test.hpp>
#include <functional>           // std::greater
#include <queue>
#include <vector>

#include <algorithm>
#include <random>


using std::priority_queue;
using std::vector;
using std::greater;
using std::less;


BOOST_AUTO_TEST_CASE(test_std_greater) {
  greater<int> g;               // a function object
  less<int> l;               // a function object
  BOOST_CHECK(g(2,1));
  BOOST_CHECK(!g(1,2));
  BOOST_CHECK(l(1,2));
}

BOOST_AUTO_TEST_CASE(test_1) {
  priority_queue<int,vector<int>,less<int>> q;

  // a random vector
  vector<int> v{1,3,2};
  // std::random_device rd;
  // std::mt19937 g(rd());
  // std::shuffle(v.begin(),v.end(),g);

  for (auto i : v){
    q.push(i);                  // sorted internally
  }
  BOOST_CHECK_EQUAL(q.top(),3); q.pop();
  BOOST_CHECK_EQUAL(q.top(),2); q.pop();
  BOOST_CHECK_EQUAL(q.top(),1);
}

#+end_src

*** Vector
**** init
#+begin_src c++
// CPP program to initialize a vector like
// an array.
#include <iostream>
#include <vector>
using namespace std;

int main()
{
	vector<int> vect{ 10, 20, 30 };

	for (int x : vect)
		cout << x << " ";

	return 0;
}

#+end_src
**** erase
#+BEGIN_SRC c++
// erasing from vector

#include <iostream>
#include <vector>
using std::cout;

#define SHOW std::cout << "myvector contains:"; \
  for (unsigned i=0; i<myvector.size(); ++i)    \
    std::cout << ' ' << myvector[i];            \
  std::cout << '\n'

int main ()
{
  std::vector<int> myvector;

  // set some values (from 1 to 10)
  for (int i=1; i<=10; i++) myvector.push_back(i);
  SHOW;

  cout << "erase the 6th element: \n";
  myvector.erase (myvector.begin()+5);
  SHOW;

  cout << "erase the first 3 elements: \n";
  myvector.erase (myvector.begin(),myvector.begin()+3);
  SHOW;


  return 0;
}

#+END_SRC
**** toString
#+begin_src c++

#ifdef _WIN32
#include <Windows.h>
#else
#include <unistd.h>
#endif

#include <cstdio>
#include <iostream>
#include <string>
#include <stack>
#include <vector>

using std::string;
using std::vector;
using std::cout;


// convert to vector to string
#include <sstream>
string v2s(vector<int> vec){
  // the vector-to-string
  std::stringstream ss;
  for(int i =0;i<vec.size();i++)
    { if(i != 0)
        { ss<<", ";
        }
      ss<< vec[i];
    }
  return ss.str();
}

#include <algorithm>            // for std::reverse
using std::reverse;
class Solution {
public:
  void nextPermutation(vector<int>& nums) {
    int L = nums.size();
    for (int i=L-2;i>-1;i--){
      if (nums[i] < nums[i+1]){
        int j = i + 1;

        while (j < (L - 1) && (nums[j+1] > nums[i])){
          j++;
        }

        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;


        // Reverse the tail-values
        // j = 1;
        // while((L - j) - (i+j) > 0){
        //   temp = nums[i+j];
        //   nums[i+j] = nums[L-j];
        //   nums[L-j] = temp;
        //   j++;
        // }
        reverse(nums.begin()+i+1, nums.end());

        return;
      }
    }

    reverse(nums.begin(),nums.end());
  }
};

int main(int argc, char *argv[]){
  Solution S;

  vector<int> nums{3,2,1};
  vector<int> nums2{1,2,3};

  S.nextPermutation(nums);
  printf("Should be %s \n it's %s \n", v2s(nums).c_str(), v2s(nums2).c_str());


  return 0;
}

#+end_src
**** iterator and distance
#+begin_src c++
  #include <cstdio>
  #include <vector>

  using std::vector;

  int main(){
    vector<int> v({1,2,3});

    auto p1 = v.begin();
    auto p2 = v.end();
    printf("*p1 is %d\n",*p1);//1
    printf("*(p2 - 1) is %d\n",*(p2 - 1)); // 3
    // Note: long int
    printf("*(p2 - p1) is %ld\n",p2 - p1); // 3
  }

#+end_src
**** find
#+begin_src c++
// CPP program to illustrate
// std::find
// CPP program to illustrate
// std::find
#include<bits/stdc++.h>

int main ()
{
	std::vector<int> vec { 10, 20, 30, 40 };
	// Element to be searched
	int ser = 30;

	// std::find function call
	std::vector<int>::iterator it =  std::find (vec.begin(), vec.end(), ser);
	if (it != vec.end())
    {
      std::cout << "Element " << ser <<" found at position : " ;
      std::cout << it - vec.begin() << " (counting from zero) \n" ;
    }
	else
		std::cout << "Element not found.\n\n";

	return 0;
}
// Output: 
// Original vector : 10 20 30 40
// Element 30 found at position : 2 (counting from zero)

#+end_src
*** List
**** basic
#+begin_src c++
#include <algorithm>
#include <iostream>
#include <list>
 
int main()
{
  // Create a list containing integers
  std::list<int> l = { 7, 5, 16, 8 };
 
  // Add an integer to the front of the list
  l.push_front(25);
  // Add an integer to the back of the list
  l.push_back(13);
 
  // Insert an integer before 16 by searching
  auto it = std::find(l.begin(), l.end(), 16);
  if (it != l.end()) {
    l.insert(it, 42);
  }
 
  // Print out the list
  std::cout << "l = { ";
  for (int n : l) {
    std::cout << n << ", ";
  }
  std::cout << "};\n";
}

#+end_src
**** random access
#+BEGIN_SRC c++
// list::begin
#include <iostream>
#include <list>

int main ()
{
  int myints[] = {75,23,65,42,13};
  std::list<int> mylist (myints,myints+5);

  std::cout << "mylist contains:";
  for (std::list<int>::iterator it=mylist.begin(); it != mylist.end(); ++it)
    std::cout << ' ' << *it;

  std::cout << '\n';

  return 0;
}
#+END_SRC
*** map
**** basic
   #+begin_src c++
/**
 * @file umap.cpp
 * @author Jianer Cong
 * @brief unordered map basic
 */

#include <unordered_map>
#include <iostream>

using std::cout;
using std::unordered_map;
using std::endl;


typedef unordered_map<int,const char*> umap;

int main(int argc, char *argv[]){
  umap m = {
            { 1 , "one"},
            {2, "two"}
  };

  cout << "Map contents are\n";
  for (const auto& [k, v] : m){
    cout << "Key " << k << " Value " << v << endl;
  }

  // Insert some value
  m.insert({3,"three"});
  m.insert({
            {4,"four"}, {5,"five"}
    });

  m.emplace(4,"NO");
  // Will not insert, since already exits/
  m.emplace(6,"six");

  cout << "Now the contents are:\n";
  for (const auto& p : m){
    cout << "\t"<< p.first << " : " << p.second << endl;
  }

  cout << "After erase one:\n";
  m.erase(1);

  for (const auto& p : m){
    cout << "\t"<< p.first << " : " << p.second << endl;
  }
  return 0;
  }

   #+end_src
**** caveat: [] access create member
#+begin_src c++
#define BOOST_TEST_MAIN
#include <boost/test/unit_test.hpp>
#include <unordered_map>

using std::unordered_map;
struct A {int a;};
BOOST_AUTO_TEST_CASE(test_1) {
  unordered_map<int,A> m;
  m[1].a = 123;                 // a new A is created
  BOOST_CHECK_EQUAL(m[1].a, 123);
} // BOOST_AUTO_TEST_CASE(test_no_1)

#+end_src
*** time
**** sleep and check
#+begin_src c++
  #define BOOST_TEST_MAIN
  #include <boost/test/unit_test.hpp>
  #include <chrono>
  #include <thread>


  using namespace std::chrono;
  BOOST_AUTO_TEST_CASE(test_1) {
    milliseconds m{1000};         // 1 sec
    m *= 2;
    BOOST_CHECK_EQUAL(m.count(),2000);
  }

  BOOST_AUTO_TEST_CASE(test_convert_to_sec) {
    milliseconds m{1000};         // 1 sec
    int sec = m.count() * milliseconds::period::num /
      milliseconds::period::den;
    BOOST_CHECK_EQUAL(sec,1);
  }

  BOOST_AUTO_TEST_CASE(test_time_sth) {
    time_point<system_clock> start, end;
    start = system_clock::now();

    using namespace std::chrono_literals;
    std::this_thread::sleep_for(3000ms); // sleep for 3sec

    end = system_clock::now();
    duration<double> elapsed_seconds = end - start;
    double s = elapsed_seconds.count();

    BOOST_CHECK(s > 2 && s < 4);  // slept for 3sec
  }

  using std::chrono::high_resolution_clock;
  using std::chrono::time_point;
  using std::chrono::duration_cast;
  using std::chrono::duration;
  BOOST_AUTO_TEST_CASE(default_time_point) {
    // using Clock= std::chrono::high_resolution_clock;
    // using TimePoint = std::chrono::time_point<Clock>;

    time_point<high_resolution_clock> p;                  // default value
    high_resolution_clock::duration d = p.time_since_epoch();

    using std::chrono::milliseconds;
    milliseconds s = std::chrono::duration_cast<milliseconds>(d);

    duration<long,std::micro> s2 = s; // ms to mus
    int i = s.count();

    BOOST_CHECK_EQUAL(i,0);
    BOOST_CHECK_EQUAL(s2.count(),0);
  }

  BOOST_AUTO_TEST_CASE(add_duration){
    using std::chrono::days;
    time_point<high_resolution_clock> p = high_resolution_clock::now();                  // default value
    time_point<high_resolution_clock> p2 = p + days(2);
    high_resolution_clock::duration d = p2 - p;
    days s = std::chrono::duration_cast<days>(d);
    /*by default use clocks duration, but we can specify it here*/

    BOOST_CHECK_EQUAL(s.count(),2);
  }
#+end_src
*** sleep
**** sleep
#+begin_src c++
#include <iostream>
#include <chrono>
#include <thread>
 
int main()
{
    using namespace std::chrono_literals;
 
    std::cout << "Hello waiter\n" << std::flush;
 
    const auto start = std::chrono::high_resolution_clock::now();
    std::this_thread::sleep_for(2000ms);
    const auto end = std::chrono::high_resolution_clock::now();
    const std::chrono::duration<double, std::milli> elapsed = end - start;
 
    std::cout << "Waited " << elapsed << '\n';
}
#+end_src
*** structure binding
#+begin_src c++

#include <bits/stdc++.h>
using namespace std;
  
struct Point
{
    int x;
    int y;
};
  
// Driver code
int main( )
{
    Point p = { 1,2 };
      
    // Structure binding
    auto[ x_coord, y_coord ] = p;
      
    cout << "X Coordinate : " << x_coord << endl;
    cout << "Y Coordinate : " << y_coord << endl;
      
    return 0;
}
#+end_src
*** tuple and structure binding
#+begin_src c++

#include<tuple> // for tuple
using std::tuple;
using std::make_tuple;
tuple<int,string_view> f(){
  return make_tuple(123,"abc");
}
BOOST_AUTO_TEST_CASE(binding){
  auto [x,y] = f();
  BOOST_CHECK_EQUAL(x,123);
  BOOST_CHECK_EQUAL(y,"abc");
}

#+end_src
*** thread
**** id
#+begin_src c++
13   std::string id() {
14      std::ostringstream out;
15      out << std::this_thread::get_id();
16      return out.str();
17   }
#+end_src

* End
# Local Variables:
# org-what-lang-is-for: "c++"
# End:
