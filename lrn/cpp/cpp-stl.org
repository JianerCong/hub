** stl
*** transform foreach (range)
#+begin_src c++
  #define BOOST_TEST_MAIN
  #include <boost/test/unit_test.hpp>
  #include <boost/format.hpp>
  using boost::format;


  #include <algorithm>
  #include <vector>
  #include <string>
  using std::string;
  using std::vector;
  // c++ 20
  namespace ranges = std::ranges;
  BOOST_AUTO_TEST_CASE(sort){
    vector<int> v{2,-1,1};
    ranges::sort(v);
    BOOST_CHECK_EQUAL(v[0],-1);
    BOOST_CHECK_EQUAL(v[1],1);
    BOOST_CHECK_EQUAL(v[2],2);

    ranges::sort(v,ranges::greater());
    BOOST_CHECK_EQUAL(v[0],2);
    BOOST_CHECK_EQUAL(v[1],1);
    BOOST_CHECK_EQUAL(v[2],-1);
  }

  struct A{
    string name;
    int x;
  };
  BOOST_AUTO_TEST_CASE(custom_sort){
    A a[]{{"y", 0}, {"x", 1}, {"z",-1}};
    ranges::sort(a, {}, &A::name); // sort by name
    BOOST_CHECK_EQUAL(a[0].name,"x");
    BOOST_CHECK_EQUAL(a[1].name,"y");
    BOOST_CHECK_EQUAL(a[2].name,"z");

    // sort by number
    ranges::sort(a, {}, &A::x); // sort by name
    BOOST_CHECK_EQUAL(a[0].x,-1);
    BOOST_CHECK_EQUAL(a[1].x,0);
    BOOST_CHECK_EQUAL(a[2].x,1);
  }

  #include <utility>              // for as_const
  BOOST_AUTO_TEST_CASE(for_each_basic){
    int x{0};
    vector<int> y = {1,2,3};
    // get
    ranges::for_each(std::as_const(y),[&](int i){x+=i;});
    // set
    ranges::for_each(y,[&](int & i){i++;});

    BOOST_CHECK_EQUAL(x,1+2+3);
    BOOST_CHECK_EQUAL(y[0],2);
    BOOST_CHECK_EQUAL(y[1],3);
    BOOST_CHECK_EQUAL(y[2],4);
    }

  BOOST_AUTO_TEST_CASE(transform){
    vector<int> v = {1,2,3};
    // vector<string> v1(v.size());         // reserve value
    vector<string> v1;// we use back_inserter

    ranges::transform(v,std::back_inserter(v1),
                      [](int c) -> string {return (format("%d") % c).str();}
                      );
    BOOST_CHECK_EQUAL(v1.size(),3);
    BOOST_CHECK_EQUAL(v1[0],"1");
    BOOST_CHECK_EQUAL(v1[1],"2");
    BOOST_CHECK_EQUAL(v1[2],"3");
    }

#+end_src
*** set
**** for basic create
#+begin_src c++
#define BOOST_TEST_MAIN
#include <boost/test/unit_test.hpp>
#include <boost/format.hpp>
using boost::format;
#include <set>

using std::set;

BOOST_AUTO_TEST_CASE(set_basic){
  set<int> s{1,2,3};
  BOOST_REQUIRE(s.contains(1));
  BOOST_CHECK_EQUAL(s.size(),3);
}

BOOST_AUTO_TEST_CASE(set_duplicate_elem_ignored){
  set<int> s{1,2,3,3};
  BOOST_REQUIRE(s.contains(1));
  BOOST_CHECK_EQUAL(s.size(),3);
}


struct A{
  int x;int y;
};
struct compA{
  constexpr bool operator()(const A & l,const A & r) const{
    return l.x < r.x;
  };
};
// two are considered equal
BOOST_AUTO_TEST_CASE(custom_set_1_explicit_comparator){
  set<A,compA> s{{1,1},{1,2}};
  BOOST_CHECK_EQUAL(s.size(),1); 
}

// --------------------------------------------------
struct B{
  int x;int y;
};
namespace std{
  // ðŸ¦œ: help std::less to use set on custom set
  template<>
  struct less<B>{
    constexpr bool operator()(const B & l,const B & r) const{
      return l.x < r.x;
    };
  };
}
// two are considered equal
BOOST_AUTO_TEST_CASE(custom_set_2_std_less){
  set<B> s{{1,1},{1,2}};
  BOOST_CHECK_EQUAL(s.size(),1);
}


// --------------------------------------------------
// with operator()
struct S {
  int x;
  S(int i) : x{i} { std::cout << "S{" << i << "} "; }
  bool operator<(S const& s) const { return x < s.x; }
};
BOOST_AUTO_TEST_CASE(custom_set_3_operator){
  std::set<S> s{3, 1, 4, 1, 5};
  BOOST_CHECK_EQUAL(s.count(1),1);
  BOOST_CHECK_EQUAL(s.count(2),0);
  BOOST_CHECK(s.contains(1));
}

// --------------------------------------------------
struct R {
  int x;
  R(int i) : x{i} { std::cout << "R{" << i << "} "; }
  bool operator<(R const& r) const { return x < r.x; }
};
bool operator<(R const& r, int i) { return r.x < i; }
bool operator<(int i, R const& r) { return i < r.x; }

BOOST_AUTO_TEST_CASE(custom_set_4_heterogeneous_lookup){
  // c++14, use int to find R
  std::set<R, std::less<>> r{3, 1, 4, 1, 5};
  BOOST_CHECK_EQUAL(r.count(1),1);
  BOOST_CHECK_EQUAL(r.count(2),0);
}

BOOST_AUTO_TEST_CASE(insert){
  set<int> s;
  auto r1 = s.insert(3);
  BOOST_REQUIRE(r1.first != s.end()); // valid iterator
  BOOST_CHECK_EQUAL(*r1.first,3);
  BOOST_REQUIRE(r1.second);     // insertion done

  auto r2 = s.insert(3);
  BOOST_CHECK(r1.first == r2.first); // same location
  BOOST_REQUIRE(not r2.second);      // no insertion

  BOOST_CHECK_EQUAL(s.size(),1);
}

#include <string>
using std::string;

// first by int, then by string
// --------------------------------------------------
// with operator()
struct S2 {
  int x;
  string n;
  S2(int i, string nn) : x{i}, n{nn} { std::cout << "S2{" << i << "," << nn << "} "; }
  bool operator<(S2 const& s) const {
    if (x == s.x and n < s.n)
      return true;
    return x < s.x;
  }
};
BOOST_AUTO_TEST_CASE(custom_set_4_operator){
  std::set<S2> s{
    {1,"a"},{1,"b"},{2,"b"},{2,"b"}
};
  BOOST_CHECK(s.contains(S2{1,"a"}));
  BOOST_CHECK(s.contains(S2{2,"b"}));
  BOOST_CHECK(not s.contains(S2{3,"b"}));
  BOOST_CHECK_EQUAL(s.count(S2{2,"b"}),1);
}

#+end_src
**** basic operation
#+begin_src c++
#define BOOST_TEST_MAIN
#include <boost/test/unit_test.hpp>
#include <boost/format.hpp>
using boost::format;
#include <set>

using std::set;


BOOST_AUTO_TEST_CASE(set_basic){
  set<int> s{1,2,3};
  BOOST_REQUIRE(s.contains(1));
  BOOST_CHECK_EQUAL(s.size(),3);
}

BOOST_AUTO_TEST_CASE(set_basic_erase){
  set<int> s{1,2,3};
  BOOST_CHECK_EQUAL(s.erase(1),1);
  BOOST_CHECK_EQUAL(s.erase(4),0);
}

BOOST_AUTO_TEST_CASE(set_basic_erase_iter){
  set<int> s{1,2,3,4};
  // Erase all odd
  for (auto it = s.begin(); it != s.end();){
    if (*it % 2 != 0)
      it = s.erase(it);
    else
      ++it;
  }

  BOOST_CHECK_EQUAL(s.size(),2);
  BOOST_CHECK(s.contains(2));
  BOOST_CHECK(s.contains(4));
}

#+end_src
**** unordered_set
#+begin_src c++
#define BOOST_TEST_MAIN
#include <boost/test/unit_test.hpp>
#include <boost/log/trivial.hpp>

#include <string>
using std::string;
#include <boost/format.hpp>
using boost::format;
#include <unordered_set>

using std::unordered_set;
// std::ostream& operator<< (std::ostream& os, std::unordered_set<int> const& s) {
//   for (os << "[" << s.size() << "] { "; int i : s)
//     os << i << ' ';
//   return os << "}\n";
// }

BOOST_AUTO_TEST_CASE(test_unordered_set_basic){
  unordered_set<int> nums = {1,2,3};
  auto [iter,ok] = nums.insert(1);
  BOOST_REQUIRE(not ok);
  BOOST_CHECK_EQUAL(nums.size(),3);

  std::tie(iter,ok) = nums.insert(4);
  BOOST_CHECK_EQUAL(nums.size(),4);
  BOOST_REQUIRE(ok);
}

#+end_src
**** set to vector
#+begin_src c++
#define BOOST_TEST_MAIN
#include <boost/test/unit_test.hpp>
#include <boost/format.hpp>
using boost::format;

#include <vector>
#include <set>
using std::vector;
using std::set;

template<typename T>
void veq(vector<T> v, vector<T> v2){
  BOOST_CHECK_EQUAL(v.size(), v2.size());
  for (int i=0;i<v.size();i++) \
    BOOST_CHECK_EQUAL(v[i],v2[i]);
};

BOOST_AUTO_TEST_CASE(test_set_to_vec){
  set<int> s{1,2,3,3};
  vector<int> v(s.begin(),s.end());
  veq(v,{1,2,3});
}

#+end_src
*** filesystem C++17
**** tests
#+begin_src c++
  #define BOOST_TEST_MAIN
  #include <boost/test/unit_test.hpp>
  #include <filesystem>
  #include <string>
  #include <string_view>
  using std::string_view;
  using std::string;


  using std::filesystem::path;
  using std::filesystem::current_path;
  namespace fs = std::filesystem;
  namespace filesystem = std::filesystem;

  #ifdef _WIN32
  #else
  // Unix-only test
  BOOST_AUTO_TEST_CASE(test_path){
    path p = "/tmp/hi.txt"; // portable format
    // fs::path p2 = "C:\\users\\abcdef\\AppData\\Local\\Temp\\"; // native format
    // fs::path p3 = U"D:/çŒ«.txt"; // UTF-32 string
    // fs::path p4 = u8"~/ç‹—.txt"; // UTF-8 string
    path f = p.filename();

    BOOST_CHECK_EQUAL(string(p),"/mp/hi.txt");
    BOOST_CHECK_EQUAL(string(path("/tmp/hi.txt").filename()),"hi.txt");
    BOOST_CHECK_EQUAL(string(path("/tmp/hi").filename()),"hi");
    BOOST_CHECK_EQUAL(string(path("/tmp/").filename()),"");
    BOOST_CHECK_EQUAL(string(path("/tmp/hi.txt").parent_path()),"/tmp");
    BOOST_CHECK(path("").empty());
    // Current path
    // BOOST_CHECK_EQUAL(string(current_path()),"/home/me/repo/hi2/build");
  }
  #endif

  BOOST_AUTO_TEST_CASE(create_check_remove_empty_dir){
    path p = "/tmp/dir1"; // portable format

    BOOST_REQUIRE(fs::create_directories(p));
    BOOST_CHECK(fs::exists(p));

    // remove empty dir
    BOOST_REQUIRE(fs::remove(p));
    BOOST_CHECK(!fs::exists(p));
  }

  BOOST_AUTO_TEST_CASE(tmp_remove_nonempty_dir){
    fs::path tmp = std::filesystem::temp_directory_path();
    BOOST_REQUIRE(fs::create_directories(tmp / "aaa/bbb"));
    BOOST_CHECK(fs::exists(tmp / "aaa"));

    // remove recursively
    std::uintmax_t n = fs::remove_all(tmp / "aaa");

    BOOST_CHECK(!fs::exists(tmp / "aaa"));
    BOOST_CHECK_EQUAL(string(tmp),"/tmp");
    BOOST_CHECK_EQUAL(n,2);
  }

  #include <fstream>
  using std::ofstream;
  BOOST_AUTO_TEST_CASE(create_write_size_delete_file){
    path p{fs::temp_directory_path() / "hi.bin"};
    if (fs::exists(p)) fs::remove(p);

    ofstream(p).put('\xff').flush();
    // For unformatted, use:
    // (ofstream(p) << '\xff').flush();

    BOOST_CHECK_EQUAL(fs::file_size(p),1);
    BOOST_REQUIRE(fs::remove(p));
  }

  BOOST_AUTO_TEST_CASE(remove_nonempty_folder){
    fs::path tmp = std::filesystem::temp_directory_path();
    BOOST_REQUIRE(fs::create_directories(tmp / "aaa"));

    path p{tmp / "aaa/hi.bin"};

    (ofstream(p) << "abc").flush();
    // For unformatted, use:
    // ofstream(p).write("abc").flush();

    BOOST_CHECK_EQUAL(fs::file_size(p),3);
    // Cannot size a dir.
    BOOST_CHECK_THROW(fs::file_size(tmp / "aaa"),fs::filesystem_error);
    BOOST_REQUIRE(fs::remove_all(tmp / "aaa"));
  }

  BOOST_AUTO_TEST_CASE(move_folder){
    fs::path tmp = std::filesystem::temp_directory_path();
    path p1{tmp / "p1"};
    path p2{tmp / "p2"};

    if (fs::exists(p1)) fs::remove_all(p1);
    if (fs::exists(p2)) fs::remove_all(p2);

    fs::create_directories(p1);
    BOOST_REQUIRE(fs::exists(p1));
    BOOST_REQUIRE(!fs::exists(p2));

    // move the folder
    fs::rename(p1,p2);

    // Now p2 exists, p1 dosen't
    BOOST_REQUIRE(!fs::exists(p1));
    BOOST_REQUIRE(fs::exists(p2));

    // remove dir
    fs::remove_all(p2);
  }

  BOOST_AUTO_TEST_CASE(move_file){
    fs::path tmp = fs::temp_directory_path();
    path f1{tmp / "f1.txt"};
    path f2{tmp / "f2.txt"};

    if (fs::exists(f1)) fs::remove(f1);
    if (fs::exists(f2)) fs::remove(f2);

    ofstream(f1).put('a').flush();
    BOOST_REQUIRE(fs::exists(f1));
    BOOST_REQUIRE(!fs::exists(f2));
    BOOST_CHECK_EQUAL(fs::file_size(f1),1);

    // move the file
    fs::rename(f1,f2);

    // Now f2 exists, f1 dosen't
    BOOST_REQUIRE(!fs::exists(f1));
    BOOST_REQUIRE(fs::exists(f2));
    BOOST_CHECK_EQUAL(fs::file_size(f2),1);

    // remove dir
    fs::remove(f2);
    BOOST_REQUIRE(!fs::exists(f2));
  }


  BOOST_AUTO_TEST_CASE(copy){
    fs::path s = fs::temp_directory_path() / "sandbox";

    fs::create_directories(s / "d1");
    ofstream(s / "d1/f1.txt").put('a').flush();

    const auto copyOptions =
      fs::copy_options::update_existing
      // Replace the existing file only if it is older than the file being
      // copied
      | fs::copy_options::recursive;
    // Recursively copy subdirectories and their content

    std::error_code err;
    // copy dir recursively
    fs::copy(s / "d1",
             s / "d2",
             copyOptions,
             err);

    BOOST_REQUIRE(!bool(err));
    BOOST_CHECK(fs::exists(s / "d2"));
    BOOST_CHECK(fs::exists(s / "d2/f1.txt"));
    BOOST_CHECK(fs::exists(s / "d1"));
    BOOST_CHECK(fs::exists(s / "d1/f1.txt"));
    BOOST_CHECK_EQUAL(fs::file_size(s / "d2/f1.txt"),1);
    BOOST_CHECK_EQUAL(fs::file_size(s / "d1/f1.txt"),1);

    fs::remove_all(s);
  }

  BOOST_AUTO_TEST_CASE(current_dir_parent_path){
    path p = filesystem::current_path();
    BOOST_CHECK_EQUAL(string(p),"/home/me/repo/build-hi2");
    BOOST_CHECK_EQUAL(string(p.parent_path()),"/home/me/repo");
    // BOOST_CHECK_EQUAL(string(p / ".."),"/home/me/repo/build-hi2/..");
    // BOOST_CHECK_EQUAL(string(filesystem::absolute(p / "..")),"/home/me/repo");
    BOOST_CHECK(string(p).starts_with("/home/me/repo"));
  }
#+end_src
**** notes on WIndo
ðŸ¦œ implicit conversion from/to std::string is only available on POSIX.

Usually, you need ~.c_str()~ or ~.native()~
#+begin_src c++
    std::filesystem::path p(u8"è¦ã‚‰ãªã„.txt");
    std::ofstream(p) << "File contents"; // Prior to LWG2676 uses operator string_type()
                                         // on MSVC, where string_type is wstring, only
                                         // works due to non-standard extension.
                                         // Post-LWG2676 uses new fstream constructors
 
    // native string representation can be used with OS APIs
    if (std::FILE* f =
#ifdef _MSC_VER
                _wfopen(p.c_str(), L"r")
#else
                std::fopen(p.c_str(), "r")
#endif
#+end_src
*** count
#+begin_src c++
#define BOOST_TEST_MAIN
#include <boost/test/unit_test.hpp>
#include <vector>               // for std::begin
#include <algorithm>        // for count


struct bytes32 {
  uint8_t bytes[32];
};

using std::begin;
using std::end;


BOOST_AUTO_TEST_CASE(test_equal) {
  bytes32 b;
  BOOST_CHECK_EQUAL(sizeof(b),sizeof(b.bytes));
  BOOST_CHECK_EQUAL(sizeof(b),32);
  BOOST_CHECK_EQUAL(sizeof(b.bytes[0]),1);

  for (int i =0;i<32;i++) b.bytes[i]=0x0;
  BOOST_CHECK_EQUAL(std::count(begin(b.bytes),end(b.bytes),0),
                    int{sizeof(b)});
}

#+end_src
*** fill, fill_n, equal, copy_
#+begin_src c++
#define BOOST_TEST_MAIN
#include <boost/test/unit_test.hpp>
// #include <iterator>               // for std::begin, but also included in algorithm
#include <algorithm>            // for std::copy_n, equal, fill, fill_n

using std::begin;
using std::end;
using std::copy_n;
using std::equal;
using std::fill;
using std::fill_n;


BOOST_AUTO_TEST_CASE(test_copy_n) {
  int a[] = {1,2,3};
  int b[] = {0,0,0,0};

  copy_n(begin(a),2,begin(b));
  BOOST_CHECK_EQUAL(b[0],1);
  BOOST_CHECK_EQUAL(b[1],2);
  BOOST_CHECK_EQUAL(b[2],0);
}

BOOST_AUTO_TEST_CASE(t2) {
  int a[] = {1,2,3};
  int b[] = {0,0,0,0};
  int r[] = {1,2,0,0};

  copy_n(begin(a),2,begin(b));
  BOOST_CHECK(equal(begin(r), end(r),begin(b)));
}


BOOST_AUTO_TEST_CASE(test_fill_bytes) {
  uint8_t a[4];fill(begin(a), end(a), 0xff);
  uint8_t b[4] = {0,0,0,0};
  uint8_t r[] = {0,0,0,0}; fill_n(begin(r)+1,2,0xff); // 0,ff,ff,0

  copy_n(begin(a),2,begin(b)+1);
  BOOST_CHECK(equal(begin(r), end(r),begin(b)));
}

#include <numeric>
BOOST_AUTO_TEST_CASE(fill_incresing_value){
  int a[3];
  std::iota(std::begin(a),std::end(a),2);
  // fill value from 2
  BOOST_CHECK_EQUAL(a[0],2);
  BOOST_CHECK_EQUAL(a[1],3);
  BOOST_CHECK_EQUAL(a[2],4);
}

BOOST_AUTO_TEST_CASE(copy_backward){
  int a[3];
  std::iota(std::begin(a),std::end(a),2); // a = {2,3,4}

  int b[6];
  int r[] = {0,0,0,2,3,4};
  fill(std::begin(b),std::end(b),0);

  std::copy_backward(std::begin(a),std::end(a),std::end(b));
  for (int i=0;i<6;i++){
    BOOST_CHECK_EQUAL(b[i],r[i]);
  }
}

#+end_src
*** weak_ptr
#+begin_src c++
#define BOOST_TEST_MAIN
#include <boost/test/unit_test.hpp>
#include <iostream>
#include <memory>

std::weak_ptr<int> p;
using std::shared_ptr;

BOOST_AUTO_TEST_CASE(t1) {
  {
    auto p1 = std::make_shared<int>(123);
    p = p1;
    BOOST_CHECK_EQUAL(p.use_count(),1);
    // how many pointers point to this
    shared_ptr<int> p2 = p.lock();
    BOOST_CHECK(p2);
    BOOST_CHECK_EQUAL(*p2,123);
  }
  // Now p1 is gone
  BOOST_CHECK_EQUAL(p.use_count(),0);
  shared_ptr<int> p2 = p.lock();
  BOOST_CHECK(!p2);
  BOOST_CHECK(p.expired());
}

#+end_src
*** unique_ptr
#+begin_src c++
  #define BOOST_TEST_MAIN
  #include <boost/test/unit_test.hpp>
  #include <memory>

  using std::unique_ptr;
  using std::make_unique;

  int x=0;
  struct A {A() {x++;} ~A() {x++;}};
  BOOST_AUTO_TEST_CASE(make_unique_ptr) {
    {
      unique_ptr<A> p = make_unique<A>();
    }
    BOOST_CHECK_EQUAL(x,2);
  }

  BOOST_AUTO_TEST_CASE(built_in_array){
    auto p(make_unique<int[]>(3));
    p[2] = 1;
    BOOST_CHECK_EQUAL(p[2],1);
  }


  /*
    ðŸ¦œ: You cannot pass unique_ptr as argument, because the cp ctor has been
    deliberately deleted... Otherwise it won't be unique would it?

    void f(unique_ptr<int> p) {(*p)++;};
    BOOST_AUTO_TEST_CASE(pass_unique_ptr) {
    {
    unique_ptr<int> p{new int(2)};
    f(p);
    BOOST_CHECK_EQUAL(*p, 3);
    }
    }
  ,*/


  unique_ptr<int> f(unique_ptr<int> p) {
    (*p)++;
    return p;
  };
  BOOST_AUTO_TEST_CASE(pass_unique_ptr) {
    {
      unique_ptr<int> p{new int(2)};
      p = f(std::move(p));       // this works
      // p = f(p);                   // this won't work
      BOOST_CHECK_EQUAL(*p, 3);
    }
  }

  BOOST_AUTO_TEST_CASE(take_away_ownership){
    unique_ptr<int> p{new int(2)};
    BOOST_REQUIRE(p);         // p is here
    f(std::move(p));
    BOOST_REQUIRE(not p);         // p is gone
    BOOST_REQUIRE(p == nullptr);
  }
  // helper class for runtime polymorphism demo below
  struct B{
    virtual ~B() = default;
  };
  BOOST_AUTO_TEST_CASE(custom_deleter){
    int x{0};
    {
      unique_ptr<B,void(*)(B*)> p(new B, [](B* toBeDeleted){
        // x++;

        // ðŸ¦œ: you cannot reference outside world here using [&], because that
        // changes the signature.
        BOOST_TEST_MESSAGE("destructor called");
        delete toBeDeleted;
      });
    }
    BOOST_CHECK_EQUAL(x,0);
  }
#+end_src
*** shared_ptr [A very important caveat]
Do not ever use
#+begin_src c++
  A a = ...;
  shared_ptr<A> p{&a};            // a is on STACK, don't try to manage it.
#+end_src
This will not make the object managed. And worst of all the compiler won't
complain anything. It will later simply give you a
#+begin_quote
[stack smashing detected ]: terminated
unknown location(0): fatal error: in "test_postExec/test_makeBlk2": signal: SIGABRT (application abort requested)
#+end_quote

*** basic_string
**** bytes
Defined in header <string>
#+begin_src c++
#define BOOST_TEST_MAIN
#include <boost/test/unit_test.hpp>
#include <string>

using bytes = std::basic_string<uint8_t>;
using std::string;


BOOST_AUTO_TEST_CASE(test_1) {
  bytes s{0,1,2,3};

  BOOST_CHECK_EQUAL(s[0],0);
  BOOST_CHECK_NE(s[2],1);
  BOOST_CHECK_EQUAL(&*(s.begin() + 1), &*s.begin() + 1);
  // *& converts iterator to pointer
  BOOST_CHECK_EQUAL(s.data(),&*s.begin());

  // pointer and array class
  BOOST_CHECK_EQUAL(2,s.data()[2]);
  BOOST_CHECK_EQUAL(s.data() + 2,&(s.data()[2]));
  BOOST_CHECK_EQUAL(&s[2],s.data() + 2);

} // BOOST_AUTO_TEST_CASE(test_no_1)

BOOST_AUTO_TEST_CASE(trim_leading_char){
  // Don't init C-string with \x00 (nullchar)
  // The following won't work

  // string s{"\x00\x00\x00\x01"};
  // size_t i = s.find_first_not_of('\x00');
  string s{"aaabc"};
  size_t i = s.find_first_not_of('a');
  BOOST_CHECK_EQUAL(i,3);
  BOOST_CHECK_EQUAL(s.substr(i),"bc");
}


BOOST_AUTO_TEST_CASE(find_first_not_of_bytes){
  string s{"\x01\x01\x01\x02"};
  size_t i = s.find_first_not_of('\x01');
  BOOST_CHECK_EQUAL(i,3);
}

BOOST_AUTO_TEST_CASE(find_first_not_of_bytes_with_null_char){
  string s;

  for (int i=0;i<3;i++)
    s.push_back('\x00');
  s.push_back('\x01');
  s.push_back('\x01');

  size_t i = s.find_first_not_of('\x00');
  BOOST_CHECK_EQUAL(i,3);
  BOOST_CHECK_EQUAL(s.substr(i),"\x01\x01");
}

#+end_src
*** bytes_view

*** ostream, osstream/istringstream,...
**** to string
#+begin_src c++
  #define BOOST_TEST_MAIN
  #include <boost/test/unit_test.hpp>
  #include <iostream>
  #include <string>
  using std::string;


  BOOST_AUTO_TEST_CASE(parse_obj) {
    std::ostringstream b;
    b << 123;
    string s = b.str();
    BOOST_CHECK_EQUAL(s,"123");
  }

  #include <sstream>
  BOOST_AUTO_TEST_CASE(serl_obj) {
    std::istringstream s(string("1 2 3"));
    int n;
    s >> n;
    BOOST_CHECK_EQUAL(n,1);
  }
#+end_src
**** class hierarchy
+ ios_base
  + basic_ios
    + basic_ostream
    + ostream = basic_ostream<char>
      + basic_ostringstream
      + ostringstream = basic_ostringstream<char>
*** check equal
#+begin_src c++
#define BOOST_TEST_MAIN
#include <boost/test/unit_test.hpp>
#include <string>
#include <bits/stdc++.h>


using bytes = std::basic_string<uint8_t>;

BOOST_AUTO_TEST_CASE(test_1) {
  bytes s{};
  s.reserve(32);
  BOOST_CHECK_EQUAL(std::count(s.begin(),s.end(),0),s.size());
}

BOOST_AUTO_TEST_CASE(test_2) {
  bytes s{1,2,2,3};
  BOOST_CHECK_EQUAL(std::count(s.begin(),s.end(),2),2);
}

BOOST_AUTO_TEST_CASE(test_equal) {
  bytes s{1,2,3};
  bytes s2{1,2,3};
  BOOST_CHECK(std::equal(s.begin(),s.end(),s2.begin()));
}

#+end_src
*** std::optional
#+begin_src c++
#define BOOST_TEST_MAIN
#include <boost/test/unit_test.hpp>
#include <string>
#include <optional>


using std::string;
std::optional<string> f(bool b) {
  if (b) return "123";
  return {};
}

BOOST_AUTO_TEST_CASE(test_1) {
  auto x = f(true);
  auto y = f(false);

  BOOST_CHECK(x);
  BOOST_CHECK_EQUAL(x.value(),string("123"));
  BOOST_CHECK_EQUAL(*x,x.value());

  BOOST_CHECK(!y);
  BOOST_CHECK_EQUAL(y.value_or("456"),string("456"));
}

#+end_src
*** hash
#+begin_src c++
#define BOOST_TEST_MAIN
#include <boost/test/unit_test.hpp>
#include <functional>           // for hash
#include <string>

using std::hash;
using std::string;


BOOST_AUTO_TEST_CASE(test_1) {
  hash<string> H;
  string s{"aaa"},s1{"bbb"},s2{"aaa"};
  size_t h{H(s)}, h1{H(s1)},h2{H(s2)};

  BOOST_CHECK_NE(h,h1);
  BOOST_CHECK_EQUAL(h,h2);
}
#+end_src
*** std::priority_queue
#+begin_src c++
#define BOOST_TEST_MAIN
#include <boost/test/unit_test.hpp>
#include <functional>           // std::greater
#include <queue>
#include <vector>

#include <algorithm>
#include <random>


using std::priority_queue;
using std::vector;
using std::greater;
using std::less;


BOOST_AUTO_TEST_CASE(test_std_greater) {
  greater<int> g;               // a function object
  less<int> l;               // a function object
  BOOST_CHECK(g(2,1));
  BOOST_CHECK(!g(1,2));
  BOOST_CHECK(l(1,2));
}

BOOST_AUTO_TEST_CASE(test_1) {
  priority_queue<int,vector<int>,less<int>> q;

  // a random vector
  vector<int> v{1,3,2};
  // std::random_device rd;
  // std::mt19937 g(rd());
  // std::shuffle(v.begin(),v.end(),g);

  for (auto i : v){
    q.push(i);                  // sorted internally
  }
  BOOST_CHECK_EQUAL(q.top(),3); q.pop();
  BOOST_CHECK_EQUAL(q.top(),2); q.pop();
  BOOST_CHECK_EQUAL(q.top(),1);
}

#+end_src

*** Vector
#+begin_src c++
#define BOOST_TEST_MAIN
#include <boost/test/unit_test.hpp>
#include <boost/format.hpp>
using boost::format;

#include <vector>
using std::vector;
#include <algorithm>

template<typename T>
void veq(vector<T> v, vector<T> v2){
  for (int i=0;i<v.size();i++) \
    BOOST_CHECK_EQUAL(v[i],v2[i]);
};


BOOST_AUTO_TEST_CASE(test_init){
	vector<int> v{ 10, 20, 30 };
  veq(v,{10,20,30});
}

BOOST_AUTO_TEST_CASE(test_ctor){
  vector<int> v(3,123);         // three copies
  veq(v,{123,123,123});

  vector<int> v1(3);
  BOOST_CHECK_EQUAL(v1.size(),3); // no copies made

  vector<int> v2{3};            // init-list
  BOOST_CHECK_EQUAL(v2.size(),1);
}

#include <numeric>
BOOST_AUTO_TEST_CASE(test_iota){ // increasing number
  vector<int> v(3);              // reserve three
  std::iota(v.begin(),v.end(),4);
  veq(v,{4,5,6});
}

BOOST_AUTO_TEST_CASE(test_erase){
  vector<int> v(4);              // reserve three
  std::iota(v.begin(),v.end(),4);
  veq(v,{4,5,6,7});

  v.erase(v.begin() + 1);
  veq(v,{4,6,7});
  }

BOOST_AUTO_TEST_CASE(test_erase_range){
  vector<int> v(5);              // reserve three
  std::iota(v.begin(),v.end(),4);
  veq(v,{4,5,6,7,8});

  v.erase(v.begin(),v.begin()+2); // first 2 element [a,b)
  veq(v,{6,7,8});
}

#include <string>
using std::string;

// convert to vector to string
#include <sstream>
template<typename T>
string v2s(vector<T> vec){
  // the vector-to-string
  std::stringstream ss;
  for(int i =0;i<vec.size();i++){
    if(i != 0) ss<<",";
    ss << vec[i];
  }
  return ss.str();
}

BOOST_AUTO_TEST_CASE(test_to_string){
  vector<int> v(3);              // reserve three
  std::iota(v.begin(),v.end(),4);
  BOOST_CHECK_EQUAL("4,5,6",v2s(v));
}

BOOST_AUTO_TEST_CASE(test_iterator_and_distance){
  vector<int> v(3);              // reserve three
  std::iota(v.begin(),v.end(),4);
  veq(v,{4,5,6});
  auto p1 = v.begin();
  auto p2 = v.end();

  BOOST_CHECK_EQUAL(*p1,4);
  BOOST_CHECK_EQUAL(*(p2-1),6);
  BOOST_CHECK_EQUAL(p2-p1,3L);  // long int
}

BOOST_AUTO_TEST_CASE(test_find){
  vector<int> v{1,2,3,3,4};

	std::vector<int>::iterator it =  std::find (v.begin(), v.end(), 3);
  BOOST_CHECK(it != v.end());   // found (the first 3)
  BOOST_CHECK_EQUAL(it - v.begin(),2);

	it =  std::find (v.begin(), v.end(), 2);
  BOOST_CHECK(it != v.end());   // not found
  BOOST_CHECK_EQUAL(it - v.begin(),1);

	it =  std::find (v.begin(), v.end(), 123);
  BOOST_CHECK(it == v.end());   // not found
}

// --------------------------------------------------
// Reserve and memory allocator
#include <cstddef>
#include <iostream>
#include <new>

// minimal C++11 allocator with debug output
template<class Tp>
struct NAlloc{
  static int allocate_count;

  typedef Tp value_type;
  NAlloc() = default;
  template<class T>
  NAlloc(const NAlloc<T>&) {}
  Tp* allocate(std::size_t n){
    allocate_count+=1;
    n *= sizeof(Tp);
    Tp* p = static_cast<Tp*>(::operator new(n));
    std::cout << "allocating " << n << " bytes @ " << p << '\n';
    // BOOST_TEST_MESSAGE((format("allocating %d bytes @%s") % n % p).str());
    return p;
  }
  void deallocate(Tp* p, std::size_t n){
    std::cout << "deallocating " << n * sizeof *p << " bytes @ " << p << "\n\n";
    // BOOST_TEST_MESSAGE((format("decallocating %d bytes @%s") % (n * sizeof *p) % p).str());
    ::operator delete(p);
  }
};
template<class T, class U>
bool operator==(const NAlloc<T>&, const NAlloc<U>&) { return true; }
template<class T, class U>
bool operator!=(const NAlloc<T>&, const NAlloc<U>&) { return false; }

// initialize the static member
// ðŸ¦œ : Must be done here, outside the class.
template<>
int NAlloc<int>::allocate_count=0;

BOOST_AUTO_TEST_CASE(test_reserve){
  constexpr int max_elements = 8;
  BOOST_TEST_MESSAGE("With reserve --------------------------");
  {
    std::vector<int, NAlloc<int>> v1;
    v1.reserve(max_elements); // reserves at least max_elements * sizeof(int) bytes

    for (int n = 0; n < max_elements; ++n) v1.push_back(n);
  }

  BOOST_CHECK_EQUAL(NAlloc<int>::allocate_count,1);
  NAlloc<int>::allocate_count=0; // reset
  BOOST_TEST_MESSAGE("Without reserve --------------------------");
  {
    std::vector<int, NAlloc<int>> v1;
    for (int n = 0; n < max_elements; ++n) v1.push_back(n);
  }
  BOOST_CHECK(NAlloc<int>::allocate_count > 1); // it will keep lengthening the array.
}

#+end_src
*** List
**** basic
#+begin_src c++
#include <algorithm>
#include <iostream>
#include <list>
 
int main()
{
  // Create a list containing integers
  std::list<int> l = { 7, 5, 16, 8 };
 
  // Add an integer to the front of the list
  l.push_front(25);
  // Add an integer to the back of the list
  l.push_back(13);
 
  // Insert an integer before 16 by searching
  auto it = std::find(l.begin(), l.end(), 16);
  if (it != l.end()) {
    l.insert(it, 42);
  }
 
  // Print out the list
  std::cout << "l = { ";
  for (int n : l) {
    std::cout << n << ", ";
  }
  std::cout << "};\n";
}

#+end_src
**** random access
#+BEGIN_SRC c++
// list::begin
#include <iostream>
#include <list>

int main ()
{
  int myints[] = {75,23,65,42,13};
  std::list<int> mylist (myints,myints+5);

  std::cout << "mylist contains:";
  for (std::list<int>::iterator it=mylist.begin(); it != mylist.end(); ++it)
    std::cout << ' ' << *it;

  std::cout << '\n';

  return 0;
}
#+END_SRC
*** map
**** basic
   #+begin_src c++
#define BOOST_TEST_MAIN
#include <boost/test/unit_test.hpp>
#include <boost/format.hpp>
using boost::format;
#include <string>

#include <unordered_map>
#include <string>
using std::string;

using std::unordered_map;

BOOST_AUTO_TEST_CASE(basic_iter){
  int c{0};
  string s;
  unordered_map<int, const char*> m = {
    {1, "aa"},
      {2, "bb"}
  };
  for (const auto &[k, v]: m){
    c += k;
    BOOST_TEST_MESSAGE(format("(k,v) = (%d,%s)") % k % v);
    // not sorted
  }
  BOOST_CHECK_EQUAL(c,3);
}

BOOST_AUTO_TEST_CASE(test_insert){
  // ðŸ¦œ : insert() is successful only if the key dosen't exist already. Usually
  // you probably means insert_or_assign()

  unordered_map<int, string> m = {{1, "aa"}, {2, "bb"}};
  BOOST_REQUIRE(m.insert({3,"cc"}).second); // ok
  BOOST_CHECK_EQUAL(m.size(),3);
  BOOST_REQUIRE(not m.insert({2,"bbb"}).second); // failed
  BOOST_CHECK_EQUAL(m.size(),3);
  BOOST_CHECK_EQUAL(m[2],"bb");

  // use insert_or_assign() ðŸ¦œ : you usually mean this
  BOOST_REQUIRE(not m.insert_or_assign(2,"bbb").second); // false means "ASSIGN"
  // ðŸ¦œ : Note that we don't have init_list now ^^^^
  BOOST_CHECK_EQUAL(m[2],"bbb");
}

BOOST_AUTO_TEST_CASE(erase){
  unordered_map<int, string> m = {{1, "aa"}, {2, "bb"}};
  BOOST_REQUIRE(m.contains(1));
  m.erase(1);
  BOOST_REQUIRE(not m.contains(1));
}

BOOST_AUTO_TEST_CASE(inplace_assignement){
  unordered_map<int, string> m = {{1, "aa"}, {2, "bb"}};
  m[1] = "aaa";
  BOOST_CHECK_EQUAL(m[1],"aaa");
  }

struct A{
  int x;
  unordered_map<int,int> m;
};
BOOST_AUTO_TEST_CASE(map_to_struct){
  unordered_map<int, A> m = {
    {
      1, {10,{}}
    },
    {
      2, {20,{}}
    }
  };
  BOOST_CHECK_EQUAL(m[1].x,10);
  BOOST_CHECK_EQUAL(m[1].m.size(),0);
}

   #+end_src
**** caveat: [] access create member
#+begin_src c++
#define BOOST_TEST_MAIN
#include <boost/test/unit_test.hpp>
#include <unordered_map>

using std::unordered_map;
struct A {int a;};
BOOST_AUTO_TEST_CASE(test_1) {
  unordered_map<int,A> m;
  m[1].a = 123;                 // a new A is created
  BOOST_CHECK_EQUAL(m[1].a, 123);
} // BOOST_AUTO_TEST_CASE(test_no_1)

#+end_src
*** time
**** sleep and check
#+begin_src c++
  #define BOOST_TEST_MAIN
  #include <boost/test/unit_test.hpp>
  #include <chrono>
  #include <thread>


  using namespace std::chrono;
  BOOST_AUTO_TEST_CASE(test_1) {
    milliseconds m{1000};         // 1 sec
    m *= 2;
    BOOST_CHECK_EQUAL(m.count(),2000);
  }

  BOOST_AUTO_TEST_CASE(test_convert_to_sec) {
    milliseconds m{1000};         // 1 sec
    int sec = m.count() * milliseconds::period::num /
      milliseconds::period::den;
    BOOST_CHECK_EQUAL(sec,1);
  }

  BOOST_AUTO_TEST_CASE(test_time_sth) {
    time_point<system_clock> start, end;
    start = system_clock::now();

    using namespace std::chrono_literals;
    std::this_thread::sleep_for(3000ms); // sleep for 3sec

    end = system_clock::now();
    duration<double> elapsed_seconds = end - start;
    double s = elapsed_seconds.count();

    BOOST_CHECK(s > 2 && s < 4);  // slept for 3sec
  }

  using std::chrono::high_resolution_clock;
  using std::chrono::time_point;
  using std::chrono::duration_cast;
  using std::chrono::duration;
  BOOST_AUTO_TEST_CASE(default_time_point) {
    // using Clock= std::chrono::high_resolution_clock;
    // using TimePoint = std::chrono::time_point<Clock>;

    time_point<high_resolution_clock> p;                  // default value
    high_resolution_clock::duration d = p.time_since_epoch();

    using std::chrono::milliseconds;
    milliseconds s = std::chrono::duration_cast<milliseconds>(d);

    duration<long,std::micro> s2 = s; // ms to mus
    int i = s.count();

    BOOST_CHECK_EQUAL(i,0);
    BOOST_CHECK_EQUAL(s2.count(),0);
  }

  BOOST_AUTO_TEST_CASE(add_duration){
    using std::chrono::days;
    time_point<high_resolution_clock> p = high_resolution_clock::now();                  // default value
    time_point<high_resolution_clock> p2 = p + days(2);
    high_resolution_clock::duration d = p2 - p;
    days s = std::chrono::duration_cast<days>(d);
    /*by default use clocks duration, but we can specify it here*/

    BOOST_CHECK_EQUAL(s.count(),2);
  }
#+end_src
*** sleep
**** sleep
#+begin_src c++
#include <iostream>
#include <chrono>
#include <thread>
 
int main()
{
    using namespace std::chrono_literals;
 
    std::cout << "Hello waiter\n" << std::flush;
 
    const auto start = std::chrono::high_resolution_clock::now();
    std::this_thread::sleep_for(2000ms);
    const auto end = std::chrono::high_resolution_clock::now();
    const std::chrono::duration<double, std::milli> elapsed = end - start;
 
    std::cout << "Waited " << elapsed << '\n';
}
#+end_src
*** structure binding from struct
#+begin_src c++

#include <bits/stdc++.h>
using namespace std;
  
struct Point
{
    int x;
    int y;
};
  
// Driver code
int main( )
{
    Point p = { 1,2 };
      
    // Structure binding
    auto[ x_coord, y_coord ] = p;
      
    cout << "X Coordinate : " << x_coord << endl;
    cout << "Y Coordinate : " << y_coord << endl;
      
    return 0;
}
#+end_src
*** tuple and structure binding
#+begin_src c++
#define BOOST_TEST_MAIN
#include <boost/test/unit_test.hpp>
#include <boost/format.hpp>
using boost::format;
#include <string>

using std::string_view;
#include<tuple> // for tuple
using std::tuple;
using std::make_tuple;
tuple<int,string_view> f(){
  return make_tuple(123,"abc");
}

BOOST_AUTO_TEST_CASE(binding){
  auto [x,y] = f();
  BOOST_CHECK_EQUAL(x,123);
  BOOST_CHECK_EQUAL(y,"abc");
}

BOOST_AUTO_TEST_CASE(bind_to_known){
  int x; string_view y;
  std::tie(x,y) = f();
  BOOST_CHECK_EQUAL(x,123);
  BOOST_CHECK_EQUAL(y,"abc");
}

BOOST_AUTO_TEST_CASE(bind_to_known_with_get){
  int x; string_view y;
  const auto o = f();
  x = std::get<0>(o);
  y = std::get<1>(o);
  BOOST_CHECK_EQUAL(x,123);
  BOOST_CHECK_EQUAL(y,"abc");
}

BOOST_AUTO_TEST_CASE(bind_ignore){
  string_view y;
  std::tie(std::ignore,y) = f();
  BOOST_CHECK_EQUAL(y,"abc");
}

#+end_src
*** thread
**** id
#+begin_src c++
13   std::string id() {
14      std::ostringstream out;
15      out << std::this_thread::get_id();
16      return out.str();
17   }
#+end_src
**** paralleled algorithm
#+begin_src c++
#define BOOST_TEST_MAIN
#include <boost/test/unit_test.hpp>
#include <boost/format.hpp>
using boost::format;

#include <algorithm>
#include <chrono> // for timing operations
#include <execution> // for execution policies
#include <iostream>
#include <iterator>
#include <random>
#include <vector>

using std::vector;

BOOST_AUTO_TEST_CASE(test_para){
  std::random_device rd;
  std::default_random_engine engine{rd()};
  std::uniform_int_distribution ints{};

  // vector<int> v1(100'000'000); // 100,000,000 element vector
  vector<int> v1(1e5); // ðŸ¦œ : Let's do 5
  // fill with random ints
  std::generate(v1.begin(), v1.end(), [&](){return ints(engine);});
  vector<int> v2{v1};           // copy

  // <chrono> library features we'll use for timing
  using std::chrono::steady_clock;
  using std::chrono::duration_cast;
  using std::chrono::milliseconds;

  auto start1{steady_clock::now()}; // get current time
  std::sort(v1.begin(), v1.end()); // sequential sort
  auto end1{steady_clock::now()}; // get current time

  auto time1{duration_cast<milliseconds>(end1 - start1)};

  // 1. --------------------------------------------------
  // Parallel sort
  auto start2{steady_clock::now()}; // get current time
  std::sort(std::execution::par, v2.begin(), v2.end()); // parallel sort
  auto end2{steady_clock::now()}; // get current time
  auto time2{duration_cast<milliseconds>(end2 - start2)};
  // std::cout << "Time: " << (time2.count() / 1000.0) << " seconds\n";

  BOOST_TEST_MESSAGE(format("serial: %.4e secs, parallel: %.4e secs") % (time1.count() /1000.0) %
                     (time2.count() /1000.0)
                     );

  BOOST_CHECK(time1.count() != time2.count());
  // ðŸ¦œ : When n=1e5, serial is actually faster
}

double timeTransform(auto policy, const std::vector<int>& v) {
  using std::chrono::steady_clock;
  using std::chrono::duration_cast;
  using std::chrono::milliseconds;

  auto start{steady_clock::now()}; // get current time
  std::vector<double> r(v.size());
  std::transform(policy,
                 v.begin(),v.end(),
                 r.begin(),[](auto x){return std::sqrt(x);});

  auto end{steady_clock::now()}; // get current time
  auto time{duration_cast<milliseconds>(end - start)};
  return time.count() / 1000.0;
}

BOOST_AUTO_TEST_CASE(test_vectorised){
  std::random_device rd;
  std::default_random_engine engine{rd()};
  std::uniform_int_distribution ints{};
  vector<int> v1(1e6); // ðŸ¦œ : Let's do 5

  // fill with random ints
  double r1 = timeTransform(std::execution::par,v1),
    r2 = timeTransform(std::execution::unseq,v1);
  std::generate(v1.begin(), v1.end(), [&](){return ints(engine);});
  BOOST_TEST_MESSAGE(format("par : %.2e sec, unseq: %.2e")
                     % r1
                     % r2);
  BOOST_CHECK_NE(r1,r2);
  // ðŸ¦œ : unseq is a bit faster..
}

#+end_src
* End
# Local Variables:
# org-what-lang-is-for: "c++"
# End:
