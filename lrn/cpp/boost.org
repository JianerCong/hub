** Boost
*** hi
**** install
#+begin_src bash
  sudo apt search libboost
  sudo apt install libboost-all-dev
#+end_src
**** cpp
#+begin_src c++
  #include <iostream>
  #include <boost/array.hpp>
  using std::cout;

  int main ()
  {
    boost::array<int,4> a = {{10, 20, 30, 30}};
    cout << "a[0]=" << a[0];

    return 0;
  }
  // Output:
  // a[0]=10
  #+end_src
**** CMakeLists.txt
#+begin_src cmake
cmake_minimum_required(VERSION 3.10)
# set the project name and version
project(Hi VERSION 1.0)

# find_package(Boost CONFIG REQUIRED)
# add the executable

add_executable(myexe test.cpp)

# cmake .. && cmake --build .
add_custom_target(run ALL myexe 1 COMMENT "Runing App 🐸")
#+end_src
*** smart point
**** sole ownership
***** unique pointer
#+begin_src c++
#include <iostream>
#include <boost/scoped_ptr.hpp>
using std::cout;

int main ()
{
  boost::scoped_ptr<int> p{new int{1}}; // cannot be copied or moved.
  cout << *p << '\n';

  p.reset(new int{2});          // release the old, point to new addr
  cout << *p.get() << '\n';

  p.reset();                    // release the allocated obj

  // cast to false if point to nothing.
  cout << std::boolalpha << static_cast<bool>(p) << '\n';

  return 0;
}

// Output:
// 1
// 2
// false

#+end_src
The destructor of this call ~delete~. To call ~delete[]~ use ~scoped_array~
****** what if we try to copy the addr
#+begin_src c++
#include <cstdio>
#include <boost/scoped_ptr.hpp>

int main ()
{
  boost::scoped_ptr<int> p{new int{1}}; // cannot be copied or moved.
  boost::scoped_ptr<int> p2{p};
  return 0;
}

// Output:
// error: ‘boost::scoped_ptr<T>::scoped_ptr(const boost::scoped_ptr<T>&) [with T = int]’ is private within this context

#+end_src
***** unique array
#+begin_src c++
#include <iostream>
#include <boost/scoped_array.hpp>
using std::cout;

int main ()
{
  boost::scoped_array<int> p{new int[2]};
  *p.get() = 10;
  p[1] = 20;
  cout << *p.get() << '\n';
  cout << p[1] << '\n';

  p.reset();                    // release the allocated obj
  // cast to false if point to nothing.
  cout << std::boolalpha << static_cast<bool>(p) << '\n';

  return 0;
}

// Output:
// 10
// 20
// false

#+end_src
**** shared ownership
#+begin_src c++
#include <boost/shared_ptr.hpp>
#include <cstdio>
#include <iostream>
using std::cout;
#define P(...) printf(__VA_ARGS__)


int main ()
{
  boost::shared_ptr<int> p1{new int{1}};
  boost::shared_ptr<int> p2{p1};

  P("*p1=%d, *p2=%d\nAfter reseting p1, p2 got ",*p1,*p2);
  p1.reset();                    // release the allocated obj
  // cast to false if point to nothing.
  cout << std::boolalpha << static_cast<bool>(p2) << '\n';

  return 0;
}
// Output
// *p1=1, *p2=1
//  After reseting p1, p2 got true


#+end_src
***** custom deleter
#+begin_src c++
#include <boost/shared_ptr.hpp>
#include <cstdio>
#include <iostream>
using std::cout;
#define P(...) printf(__VA_ARGS__)

void my_delete(int *p){
  P("Calling my own delete.\n");
  delete p;
}


int main ()
{
  boost::shared_ptr<int> p1(new int{1},my_delete);
  P("*p1 = %d\n",*p1);
  return 0;
}
// Output
// *p1 = 1
// Calling my own delete.

#+end_src
***** make_shared
more efficient than calling ~new~ to create a dynamically allocated obj and
calling ~new~ again in the constructor of ~boost::shared_ptr~ to allocate memory
for the reference counter.
#+begin_src c++
#include <boost/make_shared.hpp>
#include <cstdio>
#include <iostream>
using std::cout;
#define P(...) printf(__VA_ARGS__)

using boost::make_shared;

int main ()
{
  auto p1 = make_shared<int>(1);
  auto p2 = make_shared<int[]>(10);
  P("p1 has type %s, p2 has type %s\n",
    typeid(p1).name(),
    typeid(p2).name()
    );
}
// Output
// p1 has type N5boost10shared_ptrIiEE, p2 has type N5boost10shared_ptrIA_iEE


#+end_src
***** shared array
#+begin_src c++
#include <boost/shared_array.hpp>
#include <cstdio>
#include <iostream>
using std::cout;
#define P(...) printf(__VA_ARGS__)

using boost::shared_array;

int main ()
{
  shared_array<int> p1{new int[1]};
  {
    shared_array<int> p2{p1};
    p2[0] = 1;
  }

  P("p2 is gone, p1[0]=%d\n",p1[0]);
}
// Output
// p2 is gone, p1[0]=1



#+end_src
***** How to time it 
#+begin_src c++
// #define BOOST_SP_USE_QUICK_ALLOCATOR
#include <boost/shared_ptr.hpp>
#include <ctime>

#include <cstdio>
#include <iostream>
using std::cout;

using std::time_t;
using std::time;

#define P(...) printf(__VA_ARGS__)


#define N 20000000
int main ()
{
  boost::shared_ptr<int> p;
  std::time_t then = time(nullptr);

  for (int i = 0;i < (N); ++i)
    p.reset(new int{i});

  std::time_t now = time(nullptr);
  P("time taken %ld\n", now - then);
  // --------------------------------------------------
  int* p1;
  then = time(nullptr);

  for (int i = 0;i < (N); ++i){
    delete p1;
    p1 = new int{i};
  }
  delete p1;

  now = time(nullptr);
  P("time taken for built-in pointer %ld\n", now - then);

}
// Output? 不define更快？
// while defining QUICK
// time taken 2
// time taken for built-in pointer 0

// while not defining QUICK
// time taken 1
// time taken for built-in pointer 0

#+end_src

*** unit-test
**** hi
***** cmdline options
#+begin_src c++
The program 'myexe' is a Boost.Test module containing unit tests.

  Usage
    myexe [Boost.Test argument]... [-- [custom test module argument]...]

  Use
      myexe --help
  or  myexe --help=<parameter name>
  for detailed help on Boost.Test parameters.


  Command line flags:
   The command line flags of Boost.Test are listed below. All parameters are
   optional. You can specify parameter value either as a command line argument or
   as a value of its corresponding environment variable. If a flag is specified as
   a command line argument and an environment variable at the same time, the
   command line takes precedence. The command line argument support name guessing,
   and works with shorter names as long as those are not ambiguous.

   All the arguments after the '--' are ignored by Boost.Test.

  Environment variables:
   Every argument listed below may also be set by a corresponding
   environmentvariable. For an argument '--argument_x=<value>', the corresponding
   environment variable is 'BOOST_TEST_ARGUMENT_X=value

  The following parameters are supported:

  auto_start_dbg
    Automatically attaches debugger in case of system level failure (signal).
    --auto_start_dbg[=<boolean value>]
    -d[ <boolean value>]

  break_exec_path
    For the exception safety testing allows to break at specific execution path.
    --break_exec_path=<value>

  build_info
    Displays library build information.
    --build_info[=<boolean value>]
    -i[ <boolean value>]

  catch_system_errors
    Allows to switch between catching and ignoring system errors (signals).
    --[no_]catch_system_errors[=<boolean value>]
    -s[ <boolean value>]

  color_output
    Enables color output of the framework log and report messages.
    --[no_]color_output[=<boolean value>]
    -x[ <boolean value>]

  detect_fp_exceptions
    Enables/disables floating point exceptions traps.
    --[no_]detect_fp_exceptions[=<boolean value>]

  detect_memory_leaks
    Turns on/off memory leaks detection (optionally breaking on specified alloc
    order number).
    --detect_memory_leaks[=<alloc order number>]

  help
    Help for framework parameters.
    --help[=<parameter name>]

  list_content
    Lists the content of test tree - names of all test suites and test cases.
    --list_content[=<HRF|DOT>]

  list_labels
    Lists all available labels.
    --list_labels[=<boolean value>]

  log_format
    Specifies log format.
    --log_format=<HRF|CLF|XML|JUNIT>
    -f <HRF|CLF|XML|JUNIT>

  log_level
    Specifies the logging level of the test execution.
    --log_level=<all|success|test_suite|unit_scope|message|warning|error|cpp_exception|system_error|fatal_error|nothing>
    -l <all|success|test_suite|unit_scope|message|warning|error|cpp_exception|system_error|fatal_error|nothing>

  log_sink
    Specifies log sink: stdout (default), stderr or file name.
    --log_sink=<stderr|stdout|file name>
    -k <stderr|stdout|file name>

  logger
    Specifies log level and sink for one or several log format
    --logger=log_format,log_level,log_sink[:log_format,log_level,log_sink]

  output_format
    Specifies output format (both log and report).
    --output_format=<HRF|CLF|XML>
    -o <HRF|CLF|XML>

  random
    Allows to switch between sequential and random order of test units execution.
    Optionally allows to specify concrete seed for random number generator.
    --random[=<seed>]

  report_format
    Specifies the test report format.
    --report_format=<HRF|CLF|XML>
    -m <HRF|CLF|XML>

  report_level
    Specifies test report level.
    --report_level=<confirm|short|detailed|no>
    -r <confirm|short|detailed|no>

  report_memory_leaks_to
    File where to report memory leaks to.
    --report_memory_leaks_to=<file name>

  report_sink
    Specifies report sink: stderr(default), stdout or file name.
    --report_sink=<stderr|stdout|file name>
    -e <stderr|stdout|file name>

  result_code
    Disables test modules's result code generation.
    --[no_]result_code[=<boolean value>]
    -c[ <boolean value>]

  run_test
    Filters which tests to execute.
    --run_test=<test unit filter>
    -t <test unit filter>

  save_pattern
    Allows to switch between saving or matching test pattern file.
    --save_pattern[=<boolean value>]

  show_progress
    Turns on progress display.
    --show_progress[=<boolean value>]
    -p[ <boolean value>]

  usage
    Short message explaining usage of Boost.Test parameters.
    -?[ <boolean value>]

  use_alt_stack
    Turns on/off usage of an alternative stack for signal handling.
    --[no_]use_alt_stack[=<boolean value>]

  version
    Prints Boost.Test version and exits.
    --version[ <boolean value>]

  wait_for_debugger
    Forces test module to wait for button to be pressed before starting test run.
    --wait_for_debugger[=<boolean value>]
    -w[ <boolean value>]

    #+end_src
***** CMake
#+begin_src cmake
cmake_minimum_required(VERSION 3.10)

# set the project name and version
project(Hi VERSION 1.0)

find_package(Boost CONFIG REQUIRED
  unit_test_framework)
# add the executable

add_executable(myexe test.cpp)
target_link_libraries(myexe PUBLIC
  Boost::unit_test_framework)

# cmake .. && cmake --build .
add_custom_target(run ALL myexe --random --log_level=all COMMENT "Runing App 🐸")

#+end_src
***** cpp
#+begin_src c++
// #define BOOST_TEST_MODULE test_module_name
#define BOOST_TEST_MAIN
#include <boost/test/unit_test.hpp>

BOOST_AUTO_TEST_CASE(test_1) {
  BOOST_CHECK(1 == 1);
} // BOOST_AUTO_TEST_CASE(test_no_1)

BOOST_AUTO_TEST_CASE(test_2) {
  BOOST_CHECK(2 == 1);
}


#+end_src
**** test-not-equal
***** cmake
#+begin_src cmake
cmake_minimum_required(VERSION 3.10)

# set the project name and version
project(Hi VERSION 1.0)

find_package(Boost CONFIG REQUIRED
  unit_test_framework)
# add the executable

add_executable(myexe test.cpp)
target_link_libraries(myexe PUBLIC
  Boost::unit_test_framework)

# cmake .. && cmake --build .
add_custom_target(run ALL myexe --random --log_level=all COMMENT "Runing App 🐸")

#+end_src
***** cpp
#+begin_src c++
// #define BOOST_TEST_MAIN
#define BOOST_TEST_MODULE MyTest
#include <boost/test/unit_test.hpp>
#include <stdexcept>


BOOST_AUTO_TEST_CASE(test_1) {
  BOOST_CHECK_NE(2,1);          // 2 != 1
} // BOOST_AUTO_TEST_CASE(test_no_1)

void f(){
  throw std::runtime_error("hi");
}

BOOST_AUTO_TEST_CASE(test_2) {
  BOOST_CHECK_THROW(f(), std::runtime_error);
}


BOOST_AUTO_TEST_CASE(test_equal) {
  BOOST_CHECK_EQUAL(1, 1);
}

BOOST_AUTO_TEST_CASE(test_error) {
  BOOST_ERROR("this should give error ❄");
}


BOOST_AUTO_TEST_CASE(test_fail) {
  BOOST_FAIL("this should give fatal error ❄");
}

#+end_src
*** log
+ Backend :: decide where the data is written.
  ~boost::log::sinks::text_ostream_backend~ is initialized with a stream of type
  ~std::ostream~ and writes log entries to it.
+ Frontend :: connection between core and a backend. (Filters are here)
+ core :: the core is the central component that all log entries are routed
  through. It is implemented as a singleton. To get a pointer to the core, call
  ~boost::log::core::get()~.
* End
# Local Variables:
# org-what-lang-is-for: "c++"
# End:
