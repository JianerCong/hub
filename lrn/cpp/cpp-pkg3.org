** openssl
*** basic
#+begin_src c++

#define BOOST_TEST_MODULE test

// ü¶ú : We don't need backwards compatibility
#define OPENSSL_API_COMPAT 30000 // use 3.0.0 API
#define OPENSSL_NO_DEPRECATED 1

// include the openssl headers
#include <openssl/evp.h>

#include <boost/test/unit_test.hpp>
#include <boost/format.hpp>
#include <string_view>

using std::string_view;
using std::string;
using boost::format;

#include <vector>
using std::vector;

string sha3_it(string_view s){
  unsigned char hash[EVP_MAX_MD_SIZE];
  unsigned int l;
  EVP_MD *sha3 = EVP_MD_fetch(NULL,/*default context*/ "SHA3-256", NULL /* query string*/);
  // hash a string
  EVP_Digest(s.data(), s.size(), hash, &l, sha3, NULL);
  EVP_MD_free(sha3);

  BOOST_CHECK_EQUAL(l,256/8);   // 256 bits = 32 bytes
  return string(reinterpret_cast<char*>(hash),l);
}

BOOST_AUTO_TEST_CASE(test_hash){
  string_view s = "aaa";
  string hash = sha3_it(s);
  BOOST_CHECK_NE(hash, sha3_it("bbb"));
  // BOOST_TEST_MESSAGE(format("hash: %s") % hash);
}

BOOST_AUTO_TEST_CASE(test_param){
  const char * s = "v1";
  const char s2[] = "v2";
  OSSL_PARAM p{"k1" , OSSL_PARAM_UTF8_PTR, &s ,strlen(s), 0};
  OSSL_PARAM p2{"k2" , OSSL_PARAM_UTF8_STRING, (void*)&s2 ,sizeof(s2) - 1, 0};

  OSSL_PARAM p_set[] = {
    p,
    p2,
    OSSL_PARAM_END              // ü¶ú They require the param array be "null-terminated".
  };

  // p1: check the key --------------------------------------------------
  BOOST_CHECK_EQUAL(p.key, string("k1"));
  // check the value
  BOOST_CHECK_EQUAL(p.data_type, OSSL_PARAM_UTF8_PTR);
  BOOST_CHECK_EQUAL(p.data_size, strlen(s));
  BOOST_CHECK_EQUAL(2, strlen(s));
  BOOST_CHECK_EQUAL(p.data, &s);
  // ü¶ú: here is how you get the value, wo
  BOOST_CHECK_EQUAL(string_view( *((char **)p.data), p.data_size), "v1");

  // p2: check
  BOOST_CHECK_EQUAL(p2.key, string("k2"));
  BOOST_CHECK_EQUAL(sizeof(s2), 3);
  BOOST_CHECK_EQUAL(p2.data_size, 2);

  // ü¶ú : read the key... This seems to be the only way to read the key.
  // Copilot's suggestion (also our first attempt) gives SEGFAULT.
  
  char b[p2.data_size + 1];
  memcpy(b, p2.data, p2.data_size);
  // ü¶ú : here we use a very technical string_view to save a byte.
  BOOST_CHECK_EQUAL(string_view(b, p2.data_size), "v2");
}

string get_uft8_string(OSSL_PARAM p2){
    char b[p2.data_size];   // transient buffer
    memcpy(b, p2.data, p2.data_size);
  return string(b, p2.data_size); // copy
}

#include <openssl/param_build.h>
BOOST_AUTO_TEST_CASE(test_param_BLD){
  // ü¶ú : OSSL_PARAM_BLD is a builder for OSSL_PARAM
  OSSL_PARAM_BLD *bld = OSSL_PARAM_BLD_new();
  OSSL_PARAM *params = NULL;

  // ü¶ú : We build the param by pushing the key and value.
  BOOST_CHECK(OSSL_PARAM_BLD_push_utf8_string(bld, "k1", "v1", 0));
  BOOST_CHECK(OSSL_PARAM_BLD_push_utf8_string(bld, "k2", "v2", 0));
  params = OSSL_PARAM_BLD_to_param(bld);

  // ü¶ú : We can check the param
  BOOST_CHECK_EQUAL(params[0].key, string("k1"));
  BOOST_CHECK_EQUAL(params[0].data_type, OSSL_PARAM_UTF8_STRING);
  BOOST_CHECK_EQUAL(get_uft8_string(params[0]), "v1");
  BOOST_CHECK_EQUAL(params[1].key, string("k2"));
  BOOST_CHECK_EQUAL(get_uft8_string(params[1]), "v2");
  }

BOOST_AUTO_TEST_CASE(test_new_key){
  // ü¶ú : No freedom, No flexibility, No need of understanding PKEY generating
  // context PKEY_CTX, here is the quick way to generate a key.
  EVP_PKEY * p =
    // EVP_PKEY_Q_keygen(NULL, NULL, "X25519");
    EVP_PKEY_Q_keygen(NULL, NULL, "ED25519");

  BOOST_CHECK_NE(p, nullptr);
  BOOST_CHECK(p);
  // ü¶ú : let's get some info

  // ü¶ú : free it
  EVP_PKEY_free(p);
}

#include <memory>
using std::unique_ptr;
BOOST_AUTO_TEST_CASE(test_smart_new_keys){
  // ü¶ú : unique_ptr can help us free the key

  {
    unique_ptr<EVP_PKEY,void(*)(EVP_PKEY*)> p(EVP_PKEY_Q_keygen(NULL, NULL, "ED25519")
                                              , [](EVP_PKEY* pkey){
                                                BOOST_TEST_MESSAGE("key freed");
                                                EVP_PKEY_free(pkey);
                                              });

    BOOST_CHECK(p);
  }
}

BOOST_AUTO_TEST_CASE(test_pkey_info){
  auto f= [](EVP_PKEY* pkey){
      BOOST_TEST_MESSAGE("key freed");
      EVP_PKEY_free(pkey);
  };
  unique_ptr<EVP_PKEY,void(*)(EVP_PKEY*)> p(EVP_PKEY_Q_keygen(NULL, NULL, "ED25519"),f);
  BOOST_CHECK(p);

  BOOST_CHECK_EQUAL(EVP_PKEY_id(p.get()), EVP_PKEY_ED25519);
  BOOST_CHECK_EQUAL(EVP_PKEY_get0_type_name(p.get()),"ED25519");

  // ü¶ú : in OpenSSL '0' means 'const'
  BOOST_TEST_MESSAGE(format("key type: %s") % EVP_PKEY_get0_type_name(p.get()));
  BOOST_TEST_MESSAGE(format("description: %s") % EVP_PKEY_get0_description(p.get()));
  // "OpenSSL ED25519 implementation"
  BOOST_CHECK_EQUAL(EVP_PKEY_can_sign(p.get()), 1);
  // ü¶ú : it can sign, so it contains the public key, but not neccessarily the
  // private key.

  // ü¶ú : In contrast, an uninitialized key cannot sign. (It contains no key)
  unique_ptr<EVP_PKEY,void(*)(EVP_PKEY*)> p2(EVP_PKEY_new(), f); 
  BOOST_CHECK_EQUAL(EVP_PKEY_can_sign(p2.get()), 0);

  // ü¶ú : We can also print the key info
  // EVP_PKEY_print_public_fp(stdout, p.get(), 2 /*indent*/ , NULL);
  EVP_PKEY_print_private_fp(stdout, p.get(), 2, NULL); // print both pub and priv
}

#+end_src

*** higher
#+begin_src c++
/*
  üê¢ : EVP_PKEY is a generic structure to hold diverse types of asymmetric keys
  (also known as "key pairs"), and can be used for diverse operations, like
  signing, verifying signatures, key derivation, etc.

  The asymmetric keys themselves are often referred to as the "internal key",
  and are handled by backends, such as providers (through EVP_KEYMGMT(3)) or
  ENGINEs.
 */

// #include <openssl/ec.h>

// BOOST_AUTO_TEST_CASE(test_signature){
//   /*
//    * Fixed data to represent the private and public key.
//    */
//   const unsigned char priv_data[] = {
//     0xb9, 0x2f, 0x3c, 0xe6, 0x2f, 0xfb, 0x45, 0x68,
//     0x39, 0x96, 0xf0, 0x2a, 0xaf, 0x6c, 0xda, 0xf2,
//     0x89, 0x8a, 0x27, 0xbf, 0x39, 0x9b, 0x7e, 0x54,
//     0x21, 0xc2, 0xa1, 0xe5, 0x36, 0x12, 0x48, 0x5d
//   };
//   /* UNCOMPRESSED FORMAT */
//   const unsigned char pub_data[] = {
//     POINT_CONVERSION_UNCOMPRESSED,
//     0xcf, 0x20, 0xfb, 0x9a, 0x1d, 0x11, 0x6c, 0x5e,
//     0x9f, 0xec, 0x38, 0x87, 0x6c, 0x1d, 0x2f, 0x58,
//     0x47, 0xab, 0xa3, 0x9b, 0x79, 0x23, 0xe6, 0xeb,
//     0x94, 0x6f, 0x97, 0xdb, 0xa3, 0x7d, 0xbd, 0xe5,
//     0x26, 0xca, 0x07, 0x17, 0x8d, 0x26, 0x75, 0xff,
//     0xcb, 0x8e, 0xb6, 0x84, 0xd0, 0x24, 0x02, 0x25,
//     0x8f, 0xb9, 0x33, 0x6e, 0xcf, 0x12, 0x16, 0x2f,
//     0x5c, 0xcd, 0x86, 0x71, 0xa8, 0xbf, 0x1a, 0x47
//   };

//   // --------------------------------------------------

//   EVP_PKEY_CTX *ctx;
//   EVP_PKEY *pkey = NULL;
//   BIGNUM *priv;
//   OSSL_PARAM_BLD *param_bld;    // the builder for the params
//   OSSL_PARAM *params = NULL;    // the params to be used for the key generation
//   int exitcode = 0;

//   priv = BN_bin2bn(priv_data, sizeof(priv_data), NULL);

//   param_bld = OSSL_PARAM_BLD_new();
//   if (priv != NULL && param_bld != NULL
//       && OSSL_PARAM_BLD_push_utf8_string(param_bld, "group", "prime256v1", 0)
//       && OSSL_PARAM_BLD_push_BN(param_bld, "priv", priv)
//       && OSSL_PARAM_BLD_push_octet_string(param_bld, "pub", pub_data, sizeof(pub_data)))
//     params = OSSL_PARAM_BLD_to_param(param_bld);
//   /*
//     üê¢ : Here we pass the param:

//           group: prime256v1
//           priv: 0xb92f3ce62ffb45683996f02aaf6cdaf2898a27bf399b7e5421c2a1e53612485d
//           pub: 0x04cf20fb9a1d116c5e9fec38876c1d2f5847aba39b7923e6eb946f97dba37dbde526ca07178d2675ffcb8eb684d02402258fb9336ecf12162f5ccd8671a8bf1a47

//      ü¶ú : Where is this documented ?

//      üê¢ : EVP_PKEY-ED25519, EVP_PKEY-EC

//    */

//   ctx = EVP_PKEY_CTX_new_from_name(NULL, "EC", NULL);
//   if (ctx == NULL || params == NULL
//       || EVP_PKEY_fromdata_init(ctx) <= 0
//       || EVP_PKEY_fromdata(ctx, &pkey, EVP_PKEY_KEYPAIR, params) <= 0) {
//     // error
//     BOOST_TEST_MESSAGE("error");
//   } else {
//     /* Do what you want with |pkey| */
//     BOOST_TEST_MESSAGE("ok");
//   }

//   EVP_PKEY_free(pkey);
//   EVP_PKEY_CTX_free(ctx);
//   OSSL_PARAM_free(params);
//   OSSL_PARAM_BLD_free(param_bld);
//   BN_free(priv);
// }


#+end_src
* End
# Local Variables:
# org-what-lang-is-for: "c++"
# End:
