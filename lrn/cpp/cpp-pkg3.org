** openssl
*** hash it (hi)
#+begin_src c++

#define BOOST_TEST_MODULE test

// ü¶ú : We don't need backwards compatibility
#define OPENSSL_API_COMPAT 30000 // use 3.0.0 API
#define OPENSSL_NO_DEPRECATED 1

// include the openssl headers
#include <openssl/evp.h>

#include <boost/test/unit_test.hpp>
#include <boost/format.hpp>
#include <string_view>

using std::string_view;
using std::string;
using boost::format;

#include <vector>
using std::vector;

string sha3_it(string_view s){
  unsigned char hash[EVP_MAX_MD_SIZE];
  unsigned int l;
  EVP_MD *sha3 = EVP_MD_fetch(NULL,/*default context*/ "SHA3-256", NULL /* query string*/);
  // hash a string
  EVP_Digest(s.data(), s.size(), hash, &l, sha3, NULL);
  EVP_MD_free(sha3);

  BOOST_CHECK_EQUAL(l,256/8);   // 256 bits = 32 bytes
  return string(reinterpret_cast<char*>(hash),l);
}

BOOST_AUTO_TEST_CASE(test_hash){
  string_view s = "aaa";
  string hash = sha3_it(s);
  BOOST_CHECK_NE(hash, sha3_it("bbb"));
  // BOOST_TEST_MESSAGE(format("hash: %s") % hash);
}

#+end_src
*** key gen

*** higher
#+begin_src c++
/*
  üê¢ : EVP_PKEY is a generic structure to hold diverse types of asymmetric keys
  (also known as "key pairs"), and can be used for diverse operations, like
  signing, verifying signatures, key derivation, etc.

  The asymmetric keys themselves are often referred to as the "internal key",
  and are handled by backends, such as providers (through EVP_KEYMGMT(3)) or
  ENGINEs.
 */

// #include <openssl/ec.h>

// BOOST_AUTO_TEST_CASE(test_signature){
//   /*
//    * Fixed data to represent the private and public key.
//    */
//   const unsigned char priv_data[] = {
//     0xb9, 0x2f, 0x3c, 0xe6, 0x2f, 0xfb, 0x45, 0x68,
//     0x39, 0x96, 0xf0, 0x2a, 0xaf, 0x6c, 0xda, 0xf2,
//     0x89, 0x8a, 0x27, 0xbf, 0x39, 0x9b, 0x7e, 0x54,
//     0x21, 0xc2, 0xa1, 0xe5, 0x36, 0x12, 0x48, 0x5d
//   };
//   /* UNCOMPRESSED FORMAT */
//   const unsigned char pub_data[] = {
//     POINT_CONVERSION_UNCOMPRESSED,
//     0xcf, 0x20, 0xfb, 0x9a, 0x1d, 0x11, 0x6c, 0x5e,
//     0x9f, 0xec, 0x38, 0x87, 0x6c, 0x1d, 0x2f, 0x58,
//     0x47, 0xab, 0xa3, 0x9b, 0x79, 0x23, 0xe6, 0xeb,
//     0x94, 0x6f, 0x97, 0xdb, 0xa3, 0x7d, 0xbd, 0xe5,
//     0x26, 0xca, 0x07, 0x17, 0x8d, 0x26, 0x75, 0xff,
//     0xcb, 0x8e, 0xb6, 0x84, 0xd0, 0x24, 0x02, 0x25,
//     0x8f, 0xb9, 0x33, 0x6e, 0xcf, 0x12, 0x16, 0x2f,
//     0x5c, 0xcd, 0x86, 0x71, 0xa8, 0xbf, 0x1a, 0x47
//   };

//   // --------------------------------------------------

//   EVP_PKEY_CTX *ctx;
//   EVP_PKEY *pkey = NULL;
//   BIGNUM *priv;
//   OSSL_PARAM_BLD *param_bld;    // the builder for the params
//   OSSL_PARAM *params = NULL;    // the params to be used for the key generation
//   int exitcode = 0;

//   priv = BN_bin2bn(priv_data, sizeof(priv_data), NULL);

//   param_bld = OSSL_PARAM_BLD_new();
//   if (priv != NULL && param_bld != NULL
//       && OSSL_PARAM_BLD_push_utf8_string(param_bld, "group", "prime256v1", 0)
//       && OSSL_PARAM_BLD_push_BN(param_bld, "priv", priv)
//       && OSSL_PARAM_BLD_push_octet_string(param_bld, "pub", pub_data, sizeof(pub_data)))
//     params = OSSL_PARAM_BLD_to_param(param_bld);
//   /*
//     üê¢ : Here we pass the param:

//           group: prime256v1
//           priv: 0xb92f3ce62ffb45683996f02aaf6cdaf2898a27bf399b7e5421c2a1e53612485d
//           pub: 0x04cf20fb9a1d116c5e9fec38876c1d2f5847aba39b7923e6eb946f97dba37dbde526ca07178d2675ffcb8eb684d02402258fb9336ecf12162f5ccd8671a8bf1a47

//      ü¶ú : Where is this documented ?

//      üê¢ : EVP_PKEY-ED25519, EVP_PKEY-EC

//    */

//   ctx = EVP_PKEY_CTX_new_from_name(NULL, "EC", NULL);
//   if (ctx == NULL || params == NULL
//       || EVP_PKEY_fromdata_init(ctx) <= 0
//       || EVP_PKEY_fromdata(ctx, &pkey, EVP_PKEY_KEYPAIR, params) <= 0) {
//     // error
//     BOOST_TEST_MESSAGE("error");
//   } else {
//     /* Do what you want with |pkey| */
//     BOOST_TEST_MESSAGE("ok");
//   }

//   EVP_PKEY_free(pkey);
//   EVP_PKEY_CTX_free(ctx);
//   OSSL_PARAM_free(params);
//   OSSL_PARAM_BLD_free(param_bld);
//   BN_free(priv);
// }


#+end_src

** protobuf
*** compile it
#+begin_src powershell
  $SRC_DIR='.\hi'
  $DST_DIR="$SRC_DIR\pb_generated"
  md $DST_DIR
  .\protoc-24.4-win64\bin\protoc.exe "-I=$SRC_DIR" "--cpp_out=$DST_DIR" "$SRC_DIR\hi.proto"

  # -I: the directory in which to search for imports
  # --cpp_out: the directory in which to output .pb.cc and .pb.h files
#+end_src

* End
# Local Variables:
# org-what-lang-is-for: "c++"
# End:
