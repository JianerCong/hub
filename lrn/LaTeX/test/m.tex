\documentclass[dvipsnames]{article}
% \documentclass[dvipsnames]{ctexart}

\title{WebAssembly Binary}
\usepackage{geometry}\geometry{
  a4paper,
  total={170mm,257mm},
  left=20mm,
  top=20mm,
}

\usepackage{graphicx}

\usepackage{svg}

\usepackage[skip=5pt plus1pt, indent=0pt]{parskip}
% Color
\newcommand{\mycola}{MidnightBlue}
\newcommand{\mycolb}{Mahogany}
\newcommand{\mycolc}{OliveGreen}

\newcommand{\cola}[1]{\textcolor{\mycola}{#1}}
\newcommand{\colb}[1]{\textcolor{\mycolb}{#1}}
\newcommand{\colc}[1]{\textcolor{\mycolc}{#1}}
\newcommand{\Cola}[1]{\textcolor{\mycola}{\textbf{#1}}}

% \let\emph\relax % there's no \RedeclareTextFontCommand
% \DeclareTextFontCommand{\emph}{\bfseries}
\renewcommand{\emph}[1]{\texbf{#1}}
\usepackage{amssymb}            %\mathbb

\usepackage{fontspec}

\setmonofont{Cascadia}[
Path=/usr/share/fonts/truetype/Cascadia_Code/,
Scale=0.85,
Extension = .ttf,
UprightFont=*Code,              %find CascadiaCode.ttf
BoldFont=*CodePL,               %find CascadiaCodePL.ttf ...
ItalicFont=*CodeItalic,
BoldItalicFont=*CodePLItalic
]
% --------------------------------------------------
% Windows
% \setmonofont{Cascadia}[
% Path=C:/Windows/Fonts/,
% Extension = .ttf,
% UprightFont=*Mono,              %find CascadiaMono.ttf
% BoldFont=*Code,               %find CascadiaCodePL.ttf ...
% ItalicFont=*Code,
% BoldItalicFont=*Code
% ]


\usepackage{minted}
\usepackage{tcolorbox}
\tcbuselibrary{skins}
\tcbuselibrary{minted}
\usepackage{tikz}
\usetikzlibrary{shapes} % ellipse node shape
\usetikzlibrary{shapes.multipart} % for line breaks in node text
\usetikzlibrary{arrows.meta}    %-o arrow head
\usetikzlibrary{arrows}
\usetikzlibrary{matrix}
\usetikzlibrary{snakes}

\usepackage{amsmath}
% ??? still xelatex?
% \usepackage{xeCJK}
\usepackage{emoji}
% \setemojifont{NotoColorEmoji.ttf}[Path=C:/Users/congj/repo/myFonts/]
% \setemojifont{TwitterColorEmoji-SVGinOT.ttf}[Path=C:/Users/congj/repo/myFonts/]
\usepackage{cleveref}

\date{\today}
\author{作者}

\newtcblisting{simplec}{
  listing engine=minted,
  minted language=c++,
  minted style=vs,
  minted options={fontsize=\small,autogobble,
    % framesep=1cm
  },
  tile,
  listing only,
  % bottom=0cm,
  % nobeforeafter, 
  boxsep=0mm,
  left=1mm,
  opacityback=0.5,
  colback=gray!20
}
\tcbuselibrary{breakable}
\newtcblisting{simplepy}{
  listing engine=minted,
  minted language=python,
  minted style=vs,
  minted options={fontsize=\small,autogobble,
    % framesep=1cm
  },
  tile,
  listing only,
  % bottom=0cm,
  % nobeforeafter,
  boxsep=0mm,
  left=1mm,
  opacityback=0.5,
  colback=gray!20,
  breakable
}
\newtcolorbox{blackbox}{tile,colback=black,colupper=white,nobeforeafter,halign=flush center}

\tikzstyle{myMatrix}=[matrix of nodes,below right,
nodes={above,text centered},                  %apply to all nodes
row sep=1cm,column sep=2cm]
\tikzstyle{every node}=[inner sep=0pt]

\newcommand\uptoleft[3][-o]{\draw[very thick,#1](#2.south) |- (#3.west);}
\newcommand\uptodown[3][-o]{\draw[very thick,#1](#2.south) to [out=270,in=90] (#3.north);}
\newcommand\downtoup[3][-latex]{\draw[very thick,#1](#2.north) to [out=90,in=270] (#3.south);}

\newcommand\lefttoright[3][-latex]{\draw[very thick,#1](#2.east) to[out=0,in=180] (#3.west);}
\newcommand\lefttodown[3][-latex]{\draw[very thick,#1](#2.east) to[out=0,in=90] (#3.north);}


\newtcolorbox{leftDialogBox}{
  tile, nobeforeafter, boxsep=0pt,
  % show bounding box,
  colback=\mycola!10,
  overlay={
    \begin{scope}
      % \fill[gray!10] (frame.east) circle (2pt);
      \fill[\mycola!10] (frame.east) --
      +(0,2mm) --
      +(3mm,0) --
      +(0,-2mm)
      ;
    \end{scope}
  }}


\newtcolorbox{rightDialogBox}{
  tile, nobeforeafter, boxsep=0pt,
  % show bounding box,
  colback=\mycola!10,
  overlay={
    \begin{scope}
      % \fill[gray!10] (frame.east) circle (2pt);
      \fill[\mycola!10] (frame.west) --
      +(0,2mm) --
      +(-3mm,0) --
      +(0,-2mm);
    \end{scope}
  }}

\newcommand{\mycolaa}{\mycola!20}


\usepackage{changepage}   % for the adjustwidth environment
\newenvironment{myIndent}[1][7mm]{\begin{adjustwidth}{#1}{}}{\end{adjustwidth}}

\usepackage{tabularx}

\newcolumntype{b}{X}
\newcolumntype{s}{>{\hsize=.2\hsize}X}

% --------------------------------------------------
\begin{document}
\maketitle{}

\section{Modules}

The encoding of a \cola{mocule} starts with a preamble containing a 4-byte
\Cola{magic number} (the string \verb|\0asm|) and a \Cola{version field}. The
current version of the WebAssembly binary format is 1.

\begin{align*}
  \mathtt{magic} &= \mathtt{0x00 0x61 0x73 0x6D} \\
  \mathtt{version} &= \mathtt{0x01 0x00 0x00 0x00} \\
  \mathtt{module} &= \mathtt{magic} + \mathtt{version} + \mathtt{<other-things>}
\end{align*}

\section{Sections}

The binary encoding of modules is organized into \cola{sections}. Most sections
correspond to one component of a \cola{module} record, except that
\cola{function definitions} are split into two sections:

\begin{enumerate}
\item type declarations in the \cola{function section}
\item bodies in the \cola{code section}. (\emoji{parrot} : It's like the the
  header files and implementation file.)
\end{enumerate}
\emoji{turtle} : This seperation enables \cola{parallel} and \cola{streaming}
compilation of the functions in a module.

Each section consists of
\begin{enumerate}
\item a one-byte \cola{section id}
\item the \colb{\texttt{u32}} size of the contents, in bytes.
\item the actual \colc{contents}, whose structure is dependent on the \cola{section id}
\end{enumerate}

\cola{Every section is optional;} an omitted section is equivalent to the
section being present with empty contents. In other words, a section is either a
triple:
\[
  N\cola{: \mathtt{bytes}} + \text{content-size} \cola{: \mathtt{u32}} + \text{content}
  \cola{: B}
\]

Or an empty content. $B$ above is the ``grammar'' (structure) of the content.

\emoji{parrot} : So we first read $N$ to get a \colb{section parser}. And then
use that to parse a content right?

\emoji{turtle} : Yeah. And other than for unknown \cola{custom sections}, the
\cola{size} is not required for decoding, but can be used to skip sections when
navigating through a binary. The module is \Cola{malformed} if the size does not
match the length of the binary contents $B$.

\emoji{parrot} : What? You mean (for known section) the size can be determined
from the type $N$?

\newcommand{\heading}[1]{\multicolumn{1}{c}{#1}}
\begin{table}[htbp]
  \centering
  % \begin{tabularx}{\textwidth}{| X | X | X |}
  \begin{tabularx}{\textwidth}{sb}
    \hline
    \heading{Id}     & \heading{Section}     \\ \hline
    0& custom section\\

    1& type section\\

    2& import section\\

    3& function section\\

    4& table section\\

    5& memory section\\

    6& global section\\

    7& export section\\

    8& start section\\

    9& element section\\

    10& code section\\

    11& data section\\

    12& data count section\\
  \end{tabularx}
\end{table}

\subsection{Custom Section}

\Cola{Custom seconds} have id 0. They are intended to be used for debugging
information or third-party extensions, and are \Cola{ignored} by the WebAssembly
semantics. Their contents consist of a \cola{name} further identifying the
custom section, followed by an uninterpreted sequence of bytes for custom use.

\emoji{parrot} So the ``content'' is \cola{name + \texttt{byte*}}
\emoji{turtle} Yeah
\[ \text{content} = \mathtt{name} + \cola{\mathtt{bytes*}}\]

\subsection{Type Section}

The \cola{type section} has the id 1. It decodes into a vector of \cola{function
  types} that represent the \cola{types} component of a module.

\[ \text{content} = \cola{\mathtt{vector<functionType>}}\]

\end{document}
% Local Variables:
% TeX-engine: luatex
% TeX-command-extra-options: "-shell-escape"
% TeX-master: "m.tex"
% End: