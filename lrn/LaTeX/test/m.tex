% \documentclass[dvipsnames]{article}
\documentclass[dvipsnames]{ctexart}

\title{FollowMe 共识}
\usepackage{geometry}\geometry{
  a4paper,
  total={170mm,257mm},
  left=20mm,
  top=20mm,
}


\usepackage{svg}

\usepackage[skip=5pt plus1pt, indent=0pt]{parskip}
% Color
\newcommand{\mycola}{MidnightBlue}
\newcommand{\mycolb}{Mahogany}
\newcommand{\mycolc}{OliveGreen}

\newcommand{\cola}[1]{\textcolor{\mycola}{#1}}
\newcommand{\colb}[1]{\textcolor{\mycolb}{#1}}
\newcommand{\colc}[1]{\textcolor{\mycolc}{#1}}
\newcommand{\Cola}[1]{\textcolor{\mycola}{\textbf{#1}}}

% \let\emph\relax % there's no \RedeclareTextFontCommand
% \DeclareTextFontCommand{\emph}{\bfseries}
\renewcommand{\emph}[1]{\texbf{#1}}

\usepackage{fontspec}

% \setmonofont{Cascadia}[
% Path=/usr/share/fonts/truetype/Cascadia_Code/,
% Scale=0.85,
% Extension = .ttf,
% UprightFont=*Code,              %find CascadiaCode.ttf
% BoldFont=*CodePL,               %find CascadiaCodePL.ttf ...
% ItalicFont=*CodeItalic,
% BoldItalicFont=*CodePLItalic
% ]

% --------------------------------------------------
% Windows
\setmonofont{Cascadia}[
Path=C:/Windows/Fonts/,
% Path=C:\\Windows\\Fonts\\,
Extension = .ttf,
UprightFont=*Mono,              %find CascadiaMono.ttf
BoldFont=*Code,               %find CascadiaCodePL.ttf ...
ItalicFont=*Code,
BoldItalicFont=*Code
]


\usepackage{minted}
\usepackage{tcolorbox}
\tcbuselibrary{skins}
\tcbuselibrary{minted}
\usepackage{tikz}
\usetikzlibrary{shapes} % ellipse node shape
\usetikzlibrary{shapes.multipart} % for line breaks in node text
\usetikzlibrary{arrows.meta}    %-o arrow head
\usetikzlibrary{arrows}
\usetikzlibrary{matrix}


\usepackage{amsmath}
% ??? still xelatex?
% \usepackage{xeCJK}
\usepackage{emoji}

\newtcolorbox[auto counter]{myBox}[2][]{
  fonttitle=\bfseries,title={共识~\thetcbcounter: #2},#1
}

\tikzstyle{myNode}=[inner sep=2pt,circle,text=white]
\date{\today}
\author{作者}

\newtcblisting{simplec}{
  listing engine=minted,
  minted language=c++,
  minted style=vs,
  minted options={fontsize=\small,autogobble,
    % framesep=1cm
  },
  tile,
  listing only,
  % bottom=0cm,
  % nobeforeafter, 
  boxsep=0mm,
  left=1mm,
  opacityback=0.5,
  colback=gray!20
}

\newtcblisting{simplepy}{
  listing engine=minted,
  minted language=python,
  minted style=vs,
  minted options={fontsize=\small,autogobble,
    % framesep=1cm
  },
  tile,
  listing only,
  % bottom=0cm,
  % nobeforeafter,
  boxsep=0mm,
  left=1mm,
  opacityback=0.5,
  colback=gray!20
}
\newtcolorbox{blackbox}{tile,colback=black,colupper=white,nobeforeafter,halign=flush center}

\tikzstyle{myMatrix}=[matrix of nodes,below right,
nodes={above,text centered},                  %apply to all nodes
row sep=1cm,column sep=2cm]
\tikzstyle{every node}=[inner sep=0pt]

\newcommand\uptoleft[3][-o]{\draw[very thick,#1](#2.south) |- (#3.west);}
\newcommand\uptodown[3][-o]{\draw[very thick,#1](#2.south) to [out=270,in=90] (#3.north);}
\newcommand\downtoup[3][-latex]{\draw[very thick,#1](#2.north) to [out=90,in=270] (#3.south);}

\newcommand\lefttoright[3][-latex]{\draw[very thick,#1](#2.east) to[out=0,in=180] (#3.west);}
\newcommand\lefttodown[3][-latex]{\draw[very thick,#1](#2.east) to[out=0,in=90] (#3.north);}
\begin{document}
\maketitle

\section{听一个共识}
让我们来想一个共识。优先要求这几点：
\begin{itemize}
\item 单节点可跑
\item 可（相对方便地）动态新增节点
\end{itemize}
\emoji{parrot} : 那么最简单的应该就是
\begin{myBox}{听一个共识 Listen-to-one Consensus}
  \label{cons-a}
  \begin{itemize}
  \item 第一个起的节点为Primary。
  \item 新增的节点往Primary上连接。
  \end{itemize}
\end{myBox}

\emoji{parrot} : 这个其实本质上就是在集群内部的一个 Server-Client 架构嘛。
也就是所有人都只听Primary的。
\begin{center}
  \begin{tikzpicture}
    % \tikzstyle{every node}=[inner sep=2pt]
    \node[myNode,fill=\mycola,minimum height=4em] (a1) {主节点};
    \foreach \d in {0,60,...,300}{
      \draw[latex-, very thick] (a1) -- (\d:3cm) node[myNode,fill=gray]{新增节点};
      % \node[myNode,fill=gray]  at (\d:2cm) {};
    }
  \end{tikzpicture}
\end{center}
这个的缺点就是\cola{主机down了，集群就down了}。它的优点就是新增的节点只需要和主
节点连接就行，而且非主节点彼此不需要知道彼此。

\begin{tikzpicture}
  \emoji{parrot} 那么代码该怎么写呢？\\
  \emoji{turtle} 在写代码之前我们先定义共识所需要的接口吧。
\end{tikzpicture}
\subsection{共识需要的接口}
抽象一点讲，共识最少需要两组外部接口。
\begin{enumerate}
\item 网络，这个包括
  \begin{itemize}
  \item 接受外部的请求（监听）
  \item P2P沟通 （监听 + 发送）
  \end{itemize}
\item 执行，把一个命令写到内部存储。
\end{enumerate}
网络的接口大概可以定义为：
\begin{simplepy}
from collections.abc import Callable
class IEndpointBasedNetworkable:
    def listen(self,
               target: str,     # The target, e.g. "/"
               handler: Callable[[str,str],Optional[str]]
               # The handler, accepts
               #  - endpoint, e.g. "localhost:8080"
               #  - request data
               # returns the result
               ):
        pass
    def send(self,endpoint: str, target: str) -> str:
        # endpoint: the target, e.g. "localhost:8080"
        # target: e.g. "/hi"
        pass
\end{simplepy}
而执行的接口，大概是这样的：
\begin{simplepy}
class IExecutable:
    def execute(self,command: str):
        pass
\end{simplepy}

\subsection{\textbf{听一个共识}，伪代码实现}
那么现在我们可以开始码了,先从构建函数开始，除了执行和网络以外，构建函数还接受一
个可选的\texttt{nodeToConnect}，如果没给，则说明这个是第一个起的节点（主节点）。
\begin{simplepy}
class ListenToOneConsensus:
    def __init__(self,
                 n: IEndpointBasedNetworkable,
                 e: IExecutable,
                 nodeToConnect=''):
        self.net = n
        self.exe = e
        if nodeToConnect:
            self.primary = nodeToConnect
            self.is_primary = false
            self.start_listening_as_sub()
        else:
            self.is_primary = true
            self.start_listening_as_primary()
    ...
\end{simplepy}
\emoji{parrot} ： 那么具体primary和非primary节点都要监听哪些事件呢？
在介绍具体要监听哪些事件之前，我们最好先看一下在“时光静好”的情况下，集群是怎么
工作的：
\begin{center}
  \begin{tikzpicture}
    \node[myNode,fill=\mycola,minimum height=4em] (a1) {主节点};
    \foreach \d in {300,20}{
      \draw[latex-, very thick] (a1) -- (\d:3cm) node[myNode,fill=gray]{新增节点};
      % \node[myNode,fill=gray]  at (\d:2cm) {};
    }
    \node[text width=7cm,above left] at ([shift={(-2cm,0cm)}]a1.west){
      \begin{tcolorbox}[tile]
        \begin{itemize}
        \item 每收到一个请求：
          \begin{enumerate}
          \item 先执行一下，
          \item 然后添加到一个\cola{笔记本}里。
          \item 然后发给所有\colb{已知下级}。
          \end{enumerate}
        \item 每当有
        \end{itemize}
      \end{tcolorbox}
    }
  \end{tikzpicture}
\end{center}

\end{document}


% Local Variables:
% TeX-engine: luatex
% TeX-command-extra-options: "-shell-escape"
% End: