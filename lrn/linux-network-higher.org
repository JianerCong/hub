** OpenSSL
*** Where are the certificates ?
#+begin_src bash
  sudo cat /etc/ca-certificates.conf
  # This file lists certificates that you wish to use or to ignore to be
  # installed in /etc/ssl/certs.
  # update-ca-certificates(8) will update /etc/ssl/certs by reading this file.
  #
  # This is autogenerated by dpkg-reconfigure ca-certificates.
  # Certificates should be installed under /usr/share/ca-certificates
  # and files with extension '.crt' is recognized as available certs.
  ls /etc/ssl/certs
  # a.pem,b.pem,....
  ls /usr/share/ca-certificates/
  ls /usr/share/ca-certificates/mozilla
  # a.crt,b.crt,...
  sudo cat /usr/share/ca-certificates/mozilla/Amazon_Root_CA_1.crt
#+end_src
*** Where is the config file?
#+begin_src bash
  openssl ca
  #using configuration from /usr/lib/ssl/openssl.cnf
  #Could not open file or uri for loading CA private key from ./demoCA/private/cakey.pem

#+end_src
*** cmdline
#+begin_src python
import subprocess

import pathlib
from pathlib import Path

def make_tmp_file(f: str='tmp.txt', content: str = 'abc'):
    # Remove file if exists
    Path(f).unlink(missing_ok=True)
    o = open(f,'w')
    assert 3 == o.write(content)
    o.close()                   # flush and close

import hashlib
def test_sha1_cmdline():
    f = 'tmp.txt'
    make_tmp_file(f,'abc')

    c = subprocess.run(['openssl','dgst','-sha1',f],capture_output=True, text=True)
    # c is the CompletedProcess class
    assert c.returncode == 0
    assert c.stderr == ''
    s = c.stdout

    assert s == 'SHA1(tmp.txt)= a9993e364706816aba3e25717850c26c9cd0d89d\n'
    # compare with that of hashlib
    h = s.split('=')[-1].strip()
    assert h == 'a9993e364706816aba3e25717850c26c9cd0d89d'
    assert h == hashlib.sha1(b'abc').hexdigest()

    Path(f).unlink(missing_ok=True)
    # openssl sha1 -out d.txt tmp.txt

def test_encrypt_decrypt():
    p = 'aaaaa'                 # password

    f = 'tmp.txt'
    f1 = 'tmp-out.txt'

    make_tmp_file(f,'abc')

    # --------------------------------------------------
    # encrypt
    c = subprocess.run(['openssl','enc','-aes-128-cbc',
                        '-in',f,
                        '-k',p,  # passphrase
                        '-pbkdf2',
                        '-out',f1],capture_output=True, text=True)
    # c is the CompletedProcess class
    assert c.returncode == 0
    assert c.stderr == ''
    assert c.stdout == ''

    # --------------------------------------------------
    # decrypt
    c = subprocess.run(['openssl','enc','-d',  # decrypt
                        '-aes-128-cbc',
                        '-in',f1,
                        '-k',p,  # passphrase
                        '-pbkdf2'],capture_output=True, text=True)
    # c is the CompletedProcess class
    assert c.returncode == 0
    assert c.stderr == ''
    assert c.stdout == 'abc'

    Path(f).unlink(missing_ok=True)
    Path(f1).unlink(missing_ok=True)

    #+end_src
** telnet
    # Enter a shell to get stuff
 telnet example.com 80
 # Send a request
 GET / HTTP/1.1
 Host: example.org
 # return twice to get an html page
 # Ctrl-D to terminate 
** netcat

Use netcat to call a web server
#+begin_src bash
  nc example.com 80
  # Send a request
  GET / HTTP/1.1
  Host: example.org
  # return twice to get an html page
  # Ctrl-D to terminate
#+end_src

Use netcat to call the local server at port 7777
#+begin_src bash
  nc ::1 7777
  # Send a request
  GET / HTTP/1.1
  # return twice to get an html page
  # Ctrl-D to terminate
#+end_src

** curl
#+begin_src bash
  curl http://www.tutorialspoint.com
  curl http://www.tutorialspoint.com -i # get and show header

  # download file and save it.
  curl -O ftp://speedtest.tele2.net/1MB.zip

  # stop and resume
  curl -# -O ftp://speedtest.tele2.net/1MB.zip
  Ctr-C
  curl -C - -O ftp://speedtest.tele2.net/1MB.zip

  # Post data
  curl -d "name=curl" https://example.com
  curl --data "name=curl" https://example.com

  # upload a local file as payload
  $ curl -vX POST http://server/api/v1/places.json -d @testplace.json \
    --header "Content-Type: application/json"
#+end_src
 curl --trace-ascii hi.txt https://www.example.com > /dev/null

** ssh
 Openssh is an open-sourced version of ssh on Unix.
*** use ssh
#+begin_src bash
ssh remote_username@remote_host
#+end_src
*** Files and Dirs
 #+begin_src bash
 l /etc/ssh/
 cat /etc/ssh/sshd_config | less
 #+end_src
*** Public/private keys 
**** What are the 2 types of key generating algorithms?
      RSA and DSA
| filename             | key type        |
|----------------------+-----------------|
| ssh_host_rsa_key     | Private RSA key |
| ssh_host_rsa_key.pub | Public RSA key  |
| ssh_host_dsa_key     | Private DSA key |
| ssh_host_dsa_key.pub | Public DSA key  |
**** When you need to generate a key yourself?
When you plan to use programs such as *ssh-agent* that provide authentication
services without a password.
**** How to create SSH version 2 keys
#+begin_src bash
sudo ssh-keygen -t rsa -N '' -f /etc/ssh/my_ssh_host_rsa_key
#+end_src
**** Generate the default ssh public key
ssh-keygen
**** the format of ~authorized_keys~

ssh[type] [public key] [comment]

+ ssh-[type] :: This specifies the type of public key. The most common types are
  ssh-rsa and ssh-dsa. Dsa is based on the Digital
  Signature Algorithm and ssh-ed25519.
+ [public key] :: This is the actual public key. It is usually a long string of
  characters.

  see ~linux-multi.org~ for an example of
  authenticate with ssh-ed25519 in a multipass environment.
*** Start the ssh server
**** On Debian-based
#+begin_src bash
  sudo apt install ssh
  pgrep ssh --list-full
  # 18001 sshd: /usr/sbin/sshd -D [listener] 0 of 10-100 startups
#+end_src
sshd not installed by default.
Upon installed:
1. New keys generated
2. Server started
3. Server startup added to the bootup configuration
**** On Fedora
Installed by default
#+begin_src bash
  systemctl enable sshd           # Start sshd at boot
  systemctl start sshd            # Start the server immedietely
  cat /var/run/sshd.pid
#+end_src
*** scp
+ from remote host to current dir :: scp user@host:file .
+ a file from local machine to a remote host  :: scp file user@host:dir
+ from a remote host to another remote host :: scp user1@host1:file user2@host2:dir
** simple http server
Start a http server on the current directory
through port 8000
#+begin_src bash
  python3 -m http.server 8000
#+end_src

In this laptop's browser: > localhost:8000
In other laptop's browser: > 10.0.0.1:8000
** OpenVPN
*** hi [failed to connect to AWS internet gateway?]
Server
#+begin_src bash

  # End 1 (will be 10.200.0.1, waiting for ..02)
  sudo openvpn \
      --ifconfig 10.200.0.1 10.200.0.2 \
      --dev tun
  # use the following to daemonize(make background) it
      # --daemon --log /var/log/my-vpn1.log
  ip a show                       # show the tun0 device
  ss -tulp                        # show the listening openvpn port UDP1194
  # Note: Enable the UDP1194-port in AWS
  # Enable IP-forwarding
  # Enable simple routing
  sudo sysctl -w net.ipv4.ip_forward=1
  # Check
  sudo sysctl net.ipv4.ip_forward
  sudo sysctl -p

  # Make sure there's a route back to end2 on the end1 LAN
  LAN_IP_OF_END1="172.31.55.181"
  THIS_ROUTER="172.31.48.1"
  # make this a getway of 10.200.0.0/24
  sudo ip route add 10.200.0.0/24 via $THIS_ROUTER
  sudo ip route add 10.200.0.0/24 via $LAN_IP_OF_END1
  ip route                        # show



  # Clean-up Use the following to delete
  sudo pkill openvpn              # stop the vpn
  sudo ip route del 10.200.0.0/24 via $THIS_ROUTER


  remote_ip="ec2-34-232-66-175.compute-1.amazonaws.com"
  # End 2 (will be 10.200.0.2, waiting for ..01)
  sudo openvpn \
      --ifconfig 10.200.0.2 10.200.0.1 \
      --dev tun \
      --remote $remote_ip
      # --daemon --log /var/log/my-vpn2.log

  # At end 2, route these subnet to end 1
  x=$(host www.google.com)
  x=${x/www.google.com has address }      # address of google
  echo $x
  sudo ip route add 142.251.42.228 via 10.200.0.1 # google
#+end_
*** aws vpn end point
**** make certificate and key
***** Make certificate
To generate the server and client certificates and
keys and upload them to ACM (Amazon certificate
manager).
#+begin_src bash
  git clone https://github.com/OpenVPN/easy-rsa.git
  cd easy-rsa/easyrsa3
  # initialize a new PKI env
  ./easyrsa init-pki
  # build a new CA
  ./easyrsa build-ca nopass
  # generate the server certificate and key
  ./easyrsa build-server-full server nopass
  # Generate the client certificate and key. Make sure to save the client
  # certificate and the client private key because you will need them when you
  # configure the client.
  ./easyrsa build-client-full client1.domain.tld nopass

#+end_src
You can optionally repeat this step for each
client (end user) that requires a client
certificate and key.
***** copy to folders
Copy the server certificate and key and the client
certificate and key to a custom folder and then
navigate into the custom folder.
#+begin_src bash
  f="/home/me/secret/my-keys"
  mkdir $f
  cp pki/ca.crt $f
  cp pki/issued/server.crt $f
  cp pki/private/server.key $f
  cp pki/issued/client1.domain.tld.crt ~/custom_folder
  cp pki/private/client1.domain.tld.key $f
  cd $f
#+end_src
***** Upload to AWS ACM
You do not necessarily need to upload the client
certificate to ACM.

If the server and client certificates have been
issued by the same Certificate Authority (CA), you
can use the *server certificate ARN* for both
server and client when you create the Client *VPN
endpoint*.
**** Create client vpn end-point
Client IPv4 = 10.0.0.0/22
Authentication options = mutual authentication
Other VPN port = 1194
**** Associate a network
Target network association >> Associate target
network

VPC = my-only-vpc
subnet = us-east-1e

When you associate the first subnet with the
Client VPN endpoint, the following happens:


+ The state of the Client VPN endpoint changes to
available. Clients can now establish a VPN
connection, but they cannot access any resources
in the VPC until you add the authorization rules.

+ The local route of the VPC is automatically
  added to the Client VPN endpoint route table.

+ The VPC's default security group is
  automatically applied for the Client VPN
  endpoint.
**** Add an authorization rule for the VPC
Grant Authorization rules
destination network to enable access = <private
CIDR of VPC>
**** Provide access to internet
Route Table > Create Route
Route destination = 0.0.0.0/0
Subnetid = subnet-06...
Description = Access to internet
**** Verify security group
+ Make sure the outbound rule to allow all to
  0.0.0.0/0
+ That the security groups for the resources in
  your VPC have a rule that allows access from the
  security group that's applied to the Client VPN
  endpoint (in this case the default VPC security
  group). This enables your clients to access the
  resources in your VPC.
**** Download the client VPN endpoint config file
+ Download the [client_configuration] file
+ Put in the certificate
  #+begin_src bash
<cert>
Contents of client certificate (.crt) file
</cert>

<key>
Contents of private key (.key) file
</key>
  #+end_src
** Nginx
*** install
#+begin_src bash
  sudo apt install -y nginx
  nginx -v
  sudo systemctl start nginx
  sudo systemctl status nginx
#+end_src
*** [python tutorial]configure a site
Remove the ~default~ from ~sites-enabled~
In /etc/nginx/sites-available/my-site
#+begin_src bash
  # server_tokens               off;
  # access_log                  /var/log/nginx/mysite.access.log;
  # error_log                   /var/log/nginx/mysite.error.log;

  # This configuration will be changed to redirect to HTTPS later
  server {
    server_name               .mysite.codes; # your host's name + .
    listen                    80;
    location / {
      proxy_pass              http://localhost:8000;
      proxy_set_header        Host $host;
    }
  }
#+end_src
Test the config
#+begin_src bash
sudo service nginx configtest /etc/nginx/sites-available/my-site
#+end_src
Add symlink
#+begin_src bash
  cd /etc/nginx/sites-enabled
  # Note: replace 'supersecure' with your domain
  sudo ln -s ../sites-available/my-site .
  sudo systemctl restart nginx
#+end_src
*** watch log
#+begin_src bash
  less +F /var/log/nginx/access.log
  tail -f /var/log/nginx/access.log
  tail -50 -f /var/log/nginx/access.log
#+end_src
*** Cookbook
**** serve static
#+begin_src bash
  server {
   listen 80 default_server;
   server_name www.example.com;   # can be omited if 'default_server' is set
   location / {
   root /usr/share/nginx/html;
   # alias /usr/share/nginx/html;
   index index.html index.htm;
   }
  }
#+end_src
**** graceful reload
#+begin_src bash
  sudo nginx -s reload
#+end_src
**** HTTP load balancing
#+begin_src bash
  upstream backend {
   server 10.10.12.45:80 weight=1;
   server app.example.com:80 weight=2;
   server spare.example.com:80 backup;
  }
  server {
   location / {
   proxy_pass http://backend;
   }
  }
#+end_src
**** TCP (e.g. MySQL) load balancing
#+begin_src bash
stream {
 upstream mysql_read {
 server read1.example.com:3306 weight=5;
 server read2.example.com:3306;
 server 10.10.12.34:3306 backup;
 }
 server {
 listen 3306;
 proxy_pass mysql_read;
 }
}
#+end_src
**** Redirect HTTP to HTTPS
#+begin_src bash
server {
 listen 80 default_server;
 listen [::]:80 default_server;
 server_name _;
 return 301 https://$host$request_uri;
}
#+end_src
**** Redirecting to HTTPS Where SSL/TLS Is Terminated Before NGINX
#+begin_src bash
server {
 listen 80 default_server;
 listen [::]:80 default_server;
 server_name _;
 if ($http_x_forwarded_proto = 'http') {
 return 301 https://$host$request_uri;
 }
}
#+end_src
**** HTTP Strict Transport Security
#+begin_src bash
add_header Strict-Transport-Security max-age=31536000;
 #+end_src
*** start/stop/enable/disable
#+begin_src bash
  sudo systemctl start nginx.service
  sudo systemctl stop nginx.service
  sudo systemctl reload nginx.service
  sudo systemctl disable nginx.service
  sudo systemctl enable nginx.service

#+end_src
** Clash
*** add proxy
#+begin_src bash
  h="127.0.0.1"
  export http_proxy="http://${h}:7890"
  export https_proxy="http://${h}:7890"
  export no_proxy="localhost,127.0.0.1"

  git config --global http.proxy 'http://127.0.0.1:7890'
#+end_src
Or in ubuntu

Network > Proxy > 
# localhost,127.0.0.0/8, ::1.10.0.0.0/24
🦜 : Sometimes (often), programs doesn't recognise
CIDR/IP range. So you kinda have to expand all the
ip addresses and add them to the variable. 

To download PDF textbook from web, recommanded sites
are:

+ libgen.is
+ b-ok.cc
+ booksc.org
+ book4you.org
+ booksc.xyz
+ pdfdrive.com

#+begin_src bash
  # set x to this
  printf -v x '%s,' 10.0.0.{0..255}
  echo $x
#+end_src

** file sharing
#+begin_src bash
  sudo apt install samba
  sudo vi  /etc/samba/smb.conf

  sudo apt install smbclient
  # 在Windows上开启共享后：
  smbclient '\\XTZJ-20221017GU\Users\'
  # smb:> help

  # Nope the following dosen't work
  # mkdir ~/myWin
  # sudo apt install cifs-utils
  # sudo mount -t cifs '\\XTZJ-20221017GU\Users\' ~/myWin -o user=me,pass=123

#+end_src
* End
# Local Variables:
# org-what-lang-is-for: "bash"
# fill-column: 50
# End:
