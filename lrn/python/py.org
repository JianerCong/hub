** sleep
#+begin_src python
  import time
  time.sleep(4)                   # 4 sec
#+end_src
** subprocess
*** run() for simple one-shot command
#+begin_src python
  import subprocess

def test_non_capture():
    c = subprocess.run(['echo','hi'])
    # c is the CompletedProcess class
    assert c.args == ['echo','hi']
    assert c.returncode == 0
    assert c.stderr == None     # output not captured
    assert c.stdout == None     # output not captured


def test_capture():
    c = subprocess.run(['echo','hi'],capture_output=True, text=True)
    # c is the CompletedProcess class
    assert c.args == ['echo','hi']
    assert c.returncode == 0
    assert c.stderr == ''
    assert c.stdout == 'hi\n'

def test_cwd():
    c = subprocess.run(['pwd'],capture_output=True, text=True)
    # c is the CompletedProcess class
    assert c.returncode == 0
    assert c.stderr == ''
    assert c.stdout == '/home/me/work/lcode\n'


def test_cwd_spec():
    c = subprocess.run(['pwd'],capture_output=True, text=True, cwd='/home/me')
    # c is the CompletedProcess class
    assert c.returncode == 0
    assert c.stderr == ''
    assert c.stdout == '/home/me\n'

#+end_src
*** Popen(): if you need to send stdin to it later
#+begin_src python
  import shutil
  import sys
  from subprocess import Popen, PIPE

  def test_shutil():
      assert '/home/me/work/lcode/myenv/bin/python' == shutil.which('python')
      assert sys.executable ==  shutil.which('python3')
      assert '/usr/bin/cat' == shutil.which('cat')

  def test_popen():
      # open a process and send stdin
      p = Popen([shutil.which('cat')],stdin=PIPE,stdout=PIPE,stderr=PIPE)
      # PIPE has to be specified in order to get these to python
      out, err = p.communicate(input=b'abc\nabc',timeout=15)
      # this will send the input and wait for it to terminate, this set the returncode.
      assert p.returncode == 0
      assert out == b'abc\nabc'
      assert err == b''

  def test_popen_text():
      # open a process and send stdin
      p = Popen([shutil.which('cat')],stdin=PIPE,stdout=PIPE,stderr=PIPE,text=True)
      out, err = p.communicate(input='abc\nabc',timeout=15)
      # this will send the input and wait for it to terminate, this set the returncode.
      assert p.returncode == 0
      assert out == 'abc\nabc'
      assert err == ''

  def test_terminate():
      # open a process and send stdin
      p = Popen([shutil.which('cat')],stdin=PIPE,stdout=PIPE,stderr=PIPE)
      p.terminate()
      assert p.returncode != 0


#+end_src
** function
#+begin_src python
x = lambda a : a + 10
print(x(5))
#+end_src
** scope
1. Name _assignment_ create or change _local variables_ by default.
2. Name _references_ search at most four scopes
   - local
   - enclosing functions (if any)
   - global
   - built-in
3. Names declared in ~global~ and ~nonlocal~ statements map names to enclosing
   module and function scopes, respectively.

ü¶ú : Functions can freely use names assigned in syntactically enclosing
functions and the global scope,

but they _must_ declare such ~nonlocal~ and ~global~ in order to *change* them.

#+begin_src python
x = 1
def f():
    global x
    x += 1
f()
x# == 2

#+end_src
** yaml
#+begin_src yaml
  rest:
    url: "https://example.org/primenumbers/v1"
    port: 8443
    prime_numbers: [2, 3, 5, 7, 11, 13, 17, 19]
#+end_src
#+begin_src python
import yaml

with open('config.yml', 'r') as file:
    prime_service = yaml.safe_load(file)

print(prime_service['prime_numbers'][0])
print(prime_service['rest']['url'])
#+end_src

** date
#+begin_src python
import datetime

x = datetime.datetime.now()
print(x) 
#+end_src

*** date output
#+begin_src python
  import datetime

  print('The Date Today is  :', datetime.datetime.today())

  date_today = datetime.date.today()
  print(date_today)
  print('This Year   :', date_today.year)
  print('This Month    :', date_today.month)
  print('Month Name:',date_today.strftime('%B'))
  print('This Week Day    :', date_today.day)
  print('Week Day Name:',date_today.strftime('%A'))

  # The Date Today is  : 2018-04-22 15:38:35.835000
  # 2018-04-22
  # This Year   : 2018
  # This Month    : 4
  # Month Name: April
  # This Week Day    : 22
  # Week Day Name: Sunday
#+end_src
*** datetime arithmetic
#+begin_src python
  import datetime

  #Capture the First Date
  day1 = datetime.date(2018, 2, 12)
  print('day1:', day1.ctime())

  # Capture the Second Date
  day2 = datetime.date(2017, 8, 18)
  print('day2:', day2.ctime())

  # Find the difference between the dates
  print('Number of Days:', day1-day2)


  date_today  = datetime.date.today()

  # Create a delta of Four Days
  no_of_days = datetime.timedelta(days=4)

  # Use Delta for Past Date
  before_four_days = date_today - no_of_days
  print('Before Four Days:', before_four_days )

  # Use Delta for future Date
  after_four_days = date_today + no_of_days
  print('After Four Days:', after_four_days )

  # day1: Mon Feb 12 00:00:00 2018
  # day2: Fri Aug 18 00:00:00 2017
  # Number of Days: 178 days, 0:00:00
  # Before Four Days: 2018-04-18
  # After Four Days: 2018-04-26
#+end_src
*** compare datetime
#+begin_src python
  import datetime

  date_today  = datetime.date.today()

  print('Today is: ', date_today)
  # Create a delta of Four Days
  no_of_days = datetime.timedelta(days=4)

  # Use Delta for Past Date
  before_four_days = date_today - no_of_days
  print('Before Four Days:', before_four_days )

  after_four_days =  date_today + no_of_days

  date1 = datetime.date(2018,4,4)

  print('date1:',date1)

  if date1 == before_four_days :
      print('Same Dates')
  if date_today > date1:
      print('Past Date')
  if date1 < after_four_days:
      print('Future Date')
  # Today is:  2018-04-22
  # Before Four Days: 2018-04-18
  # date1: 2018-04-04
  # Past Date
  # Future Date
    #+end_src
*** create date object
#+begin_src python
import datetime
y = datetime.date.fromisoformat('2019-12-04')
x = datetime.datetime(2020, 5, 17)

print(x) 
#+end_src

*** strftime() method
#+begin_src python
import datetime

x = datetime.datetime(2018, 6, 1)

print(x.strftime("%B")) 
#+end_src
https://www.w3schools.com/python/python_datetime.asp

** print

print(object(s), sep=separator, end=end, file=file, flush=flush)

** souce a file
#+begin_src python
exec(open('filename').read())
#+end_src
** Q&A
*** Encoding issue when reading lines from windows?
    #+begin_src python
      f = open('hi.txt', 'r', encoding = 'utf8')
      import locale
      local.getpreferredencoding()    # 'cp1252' on windows
    #+end_src
** string and numbers
*** basic
#+begin_src python
  a = 'Apple'
  b = 1.23
  m = '%s costs %d USD' % (a,b)

  # binary format
  bin(5)                          # 0b101
  bin(5).replace('0b','')         # 101
  # pad with 0
  bin(1).replace('0b','').zfill(4)  # 0001
#+end_src
Reverse string.
In this particular example, the slice statement [::-1] means start at the end of
the string and end at position 0, move with the step -1, negative one, which
means one step backwards.
#+begin_src python
txt = "Hello World" [::-1]
print(txt) 
#+end_src
*** parse
#+begin_src python
  int('101', 2)                   # ‚áí 5
  int('f',16)                     # ‚áí 15
  int('ff',16)                    # ‚áí 255
#+end_src
*** format
#+begin_src python
  '%x' % 12                       # c
  '%X' % 12                       # C
#+end_src
*** re
**** re.match: match from beginning
If zero or more characters at the *beginning* of string match the regular
expression pattern, return a corresponding match object.

Return ~None~ if the string does not match the pattern; note that this is
different from a zero-length match.
#+begin_src python
  bool(re.match('A','A1'))        # True
  bool(re.match('1','A1'))        # False
#+end_src
**** re.search: contains the pattern
Scan through string looking for the *first location* where the regular expression
pattern produces a match, and return a corresponding match object.
#+begin_src python
  import re

  step = 'A1'
  m = re.search('^([A-Z])([0-9]{1,2})$',step)
  if m:
      print(f'{m.group(1)}, {m.group(2)}')
  else:
      print('Not valid')
      # A, 1
  m.groups()                      # ('A','1')
    #+end_src

Return ~None~ if no position in the string matches the pattern; note that this is
different from finding a zero-length match at some point in the string.
**** re.fullmatch(pattern,string)
match the whole string ‚áí Match Object
#+begin_src python
  import re

  s = 'abcde'
  bool(re.fullmatch('bc',s))      # False
  bool(re.fullmatch('abcde',s))   # True
    #+end_src
**** re.findall(pattern,string,flag)
#+begin_src python
re.findall(r'\bf[a-z]*', 'which foot or hand fell fastest')
#+end_src
Return all non-overlapping matches of pattern in string, as a list of strings or
tuples. The string is scanned left-to-right, and matches are returned in the
order found. Empty matches are included in the result.

The result depends on the number of capturing groups in the pattern.

+ If there are no groups, return a list of strings matching the whole pattern.
+ If there is exactly one group, return a list of strings matching that group.
+ If multiple groups are present, return a list of tuples of strings matching
  the groups.

Non-capturing groups do not affect the form of the result.
**** re.sub(pattern, replacement, string): replace regexp
replace regexp
#+begin_src python
  re.sub(r'def\s+([a-zA-Z_][a-zA-Z_0-9]*)\s*\(\s*\):',
         r'static PyObject*\npy_\1(void)\n{',
         'def myfunc():')
  'static PyObject*\npy_myfunc(void)\n{'
       #+end_src
**** match object
#+begin_src python
  r = re.search('abc','abcyyyyabc')
  r.pos                           # 0
  r.start()                       # 0
  r.end()                         # 3
  r.span()                        # (0,3)
#+end_src

**** greedy match
*?, +?, ??

The '*', '+', and '?' quantifiers are all greedy; they match as much text as
possible. Sometimes this behaviour isn‚Äôt desired; if the RE <.*> is matched
against '<a> b <c>', it will match the entire string, and not just '<a>'. Adding
? after the quantifier makes it perform the match in non-greedy or minimal
fashion; as few characters as possible will be matched. Using the RE <.*?> will
match only '<a>'.
** collections
*** dic
#+begin_src python
  d = {'a':22,'b':44,'c':'na'}
  d['c']
  d['d'] = 23
  d.get('e','Not Found')
  'a' in d                        # True
  22 in d.values()                # True
  items(d)                        # list of pair
  d.keys()                            # list of keys

  bob2 = dict(zip(['name', 'job', 'age'], ['Bob', 'dev', 40])) # Zipping
  bob1 = dict(name='Bob', job='dev', age=40) # Keywords

  for k in sorted(d.keys()):
    print(k)

  # delete a key
  bob1.pop('name')
#+end_src
*** set
#+begin_src python
  thisset = set(("apple", "banana", "cherry")) # note the double round-brackets
  myset = {"apple", "banana", "cherry"}
  thisset = {"apple", "banana", "cherry", "apple"}  # duplicated vals are ignored

  m = set({})
  m.add(1)
  1 in m                          # True
  m.discard(1)
  1 in m                          # False
  len(0)                          # 0
 #+end_src
*** ordered dict
#+begin_src python
  # A Python program to demonstrate working of OrderedDict
  from collections import OrderedDict

  print("This is a Dict:\n")
  d = {}
  d['a'] = 1
  d['b'] = 2
  d['c'] = 3
  d['d'] = 4

  for key, value in d.items():
    print(key, value)
  # a 1
  # c 3
  # b 2
  # d 4

  print("\nThis is an Ordered Dict:\n")
  od = OrderedDict()
  od['a'] = 1
  od['b'] = 2
  od['c'] = 3
  od['d'] = 4

  for key, value in od.items():
    print(key, value)
  This is a Dict:

  # This is an Ordered Dict:
  # a 1
  # b 2
  # c 3
  # d 4
#+end_src
*** sorted
#+begin_src python

  L = ["cccc", "b", "dd", "aaa"]
  print("Normal sort :", sorted(L))
  print("Sort with len :", sorted(L, key=len))

  # Normal sort : ['aaa', 'b', 'cccc', 'dd']
  # Sort with len : ['b', 'dd', 'aaa', 'cccc']


  x = [2, 8, 1, 4, 6, 3, 7]
  print("Sorted List returned :", sorted(x))
  print("Reverse sort :", sorted(x, reverse=True))
  print("\nOriginal list not modified :", x)
  # Sorted List returned : [1, 2, 3, 4, 6, 7, 8]
  # Reverse sort : [8, 7, 6, 4, 3, 2, 1]

  # Original list not modified : [2, 8, 1, 4, 6, 3, 7]
#+end_src
*** functools
**** reduce: reverse sort a string
#+begin_src python

# import the module
import functools
# initializing string
test_string = "geekforgeeks"
  
# printing original string
print("The original string : " + str(test_string))
  
# using sorted() + reduce() + lambda
# Reverse Sort a String
res = functools.reduce(lambda x, y: x + y,
                       sorted(test_string, 
                              reverse=True))
# print result
print("String after reverse sorting : " + str(res))
#+end_src
*** list
**** delete
#+begin_src python
  myList = [‚Äòa‚Äô , ‚Äòb‚Äô , ‚Äòc‚Äô , ‚Äòd‚Äô , ‚Äòe‚Äô , ‚Äòf‚Äô , ‚Äòg‚Äô , ‚Äòh‚Äô , ‚Äòi‚Äô , ‚Äòj‚Äô , ‚Äòk‚Äô , ‚Äòl‚Äô]
  #delete the third item (index = 2)
  del myList[2]
  print (myList)
  # => [‚Äòa‚Äô, ‚Äòb‚Äô, ‚Äòd‚Äô, ‚Äòe‚Äô, ‚Äòf‚Äô, ‚Äòg‚Äô, ‚Äòh‚Äô, ‚Äòi‚Äô, ‚Äòj‚Äô, ‚Äòk‚Äô, ‚Äòl‚Äô]

  #delete items from index 1 to 5-1 --------------------------------------------------
  del myList[1:5]
  print (myList)
  # => [‚Äòa‚Äô, ‚Äòg‚Äô, ‚Äòh‚Äô, ‚Äòi‚Äô, ‚Äòj‚Äô, ‚Äòk‚Äô, ‚Äòl‚Äô]
  #delete items from index 0 to 3-1 --------------------------------------------------
  del myList [ :3]
  print (myList)
  # => [‚Äòi‚Äô, ‚Äòj‚Äô, ‚Äòk‚Äô, ‚Äòl‚Äô]
  #delete items from index 2 to end --------------------------------------------------
  del myList [2:]
  print (myList)
  # => [‚Äòi‚Äô, ‚Äòj‚Äô]
#+end_src
**** insert
#+begin_src python


  myList = [‚Äòa‚Äô , ‚Äòb‚Äô , ‚Äòc‚Äô , ‚Äòd‚Äô]
  ‚Äòc‚Äô in myList
  myList = [‚Äòa‚Äô , ‚Äòb‚Äô , ‚Äòc‚Äô , ‚Äòd‚Äô , ‚Äòe‚Äô]
  myList.insert(1, ‚ÄòHi‚Äô)
  print (myList)
  # => [‚Äòa‚Äô, ‚ÄòHi‚Äô, ‚Äòb‚Äô, ‚Äòc‚Äô, ‚Äòd‚Äô, ‚Äòe‚Äô]

  #+end_src
**** pop()
#+begin_src python
  myList = [‚Äòa‚Äô , ‚Äòb‚Äô , ‚Äòc‚Äô , ‚Äòd‚Äô , ‚Äòe‚Äô]
  #remove the third item
  member = myList.pop(2)
  print (member)
  # => c
  print (myList)
  # => [‚Äòa‚Äô, ‚Äòb‚Äô, ‚Äòd‚Äô, ‚Äòe‚Äô]

  #remove the last item
  member = myList.pop( )
  print (member)
  # => e
  print (myList)
  # => [‚Äòa‚Äô, ‚Äòb‚Äô, ‚Äòd‚Äô]
#+end_src
**** index()
#+begin_src python
  l = [10,20]
  l.index(20)                      # 1
#+end_src

** work with file
#+begin_src python
  import pathlib
  from pathlib import Path

  def test_write():
      f = 'test.txt'
      # Remove file if exists
      Path(f).unlink(missing_ok=True)

      o = open(f,'w')
      assert 3 == o.write('abc')
      o.close()                   # flush and close
      assert Path(f).exists()

  def test_flush_read():
      f = 'test.txt'
      # Remove file if exists
      Path(f).unlink(missing_ok=True)

      o = open(f,'w')
      i = open(f)                 # default to read
      assert 3 == o.write('abc')
      assert i.read() == ''       # not flushed yet
      o.flush()
      assert i.read() == 'abc'    # now can be read
      o.close()                   # flush and close
      assert Path(f).exists()

  def test_read_writelines():
      f = 'test.txt'
      # Remove file if exists
      Path(f).unlink(missing_ok=True)

      o = open(f,'w')
      i = open(f)                 # default to read
      o.writelines(['aa','bb','cc'])
      o.flush()
      assert i.read() == 'aabbcc'    # writelines() dosen't add \n itself
      o.close()                   # flush and close
      assert Path(f).exists()

  def test_readlines_write():
      f = 'test.txt'
      # Remove file if exists
      Path(f).unlink(missing_ok=True)

      o = open(f,'w')
      i = open(f)                 # default to read
      assert 5 == o.write('a\nb\nc')
      o.flush()
      assert i.readlines() == ['a\n','b\n','c']    # readlines doesn't remove \n
      o.close()                   # flush and close
      assert Path(f).exists()


  def test_seek():
      f = 'test.txt'
      # Remove file if exists
      Path(f).unlink(missing_ok=True)

      o = open(f,'w')
      i = open(f)                 # default to read
      assert 3 == o.write('abc')
      o.flush()
      assert i.read() == 'abc'
      # the pointer is reset
      assert i.read() == ''
      i.seek(0)                   # reset to 0
      assert i.read() == 'abc'
      o.close()                   # flush and close
      assert Path(f).exists()
      Path(f).unlink(missing_ok=True)
    #+end_src
** try except
*** raise and except
#+begin_src python
  try:
      f()
  except IndexError:
      print('Got exception')
  print('Continuing')

  
  try:
      raise IndexError
  except IndexError:
      print('Got exception')
  print('Continuing')

  try:
      f()
  except Exception as X:
      print(X)
#+end_src
*** define your own exception by inheriting the Exception
#+begin_src python
  class MyError(Exception): pass
  def h():
      raise MyError()

  try:
      h()
  except MyError:
      print('Got MyError')
#+end_src
*** Catch all exceptions
except clauses that list no exception name ( except: ) catch all exceptions not pre-
viously listed in the try statement.
#+begin_src python
  try:
      action()
  except NameError: # Handle NameError
      ...
  except IndexError: # Handle IndexError
      ...
  except: # Handle all other exceptions
      ...
#+end_src
** asyncio
*** hi
#+begin_src python
  import asyncio

  async def main():
      print('Hello ...')
      await asyncio.sleep(1)
      print('... World!')

  asyncio.run(main())

#+end_src
*** return hello
#+begin_src python
  import asyncio

  async def main():
      print('Hello ...')
      x = await asyncio.sleep(10, result='hello')
      print(f'... World! x={x}')

  asyncio.run(main())
#+end_src
** concurrent
*** thread-pool
#+begin_src python
x = 1
def f():
    global x
    x = 2

def test_scope():
    f()
    assert  x == 2

from time import sleep
from concurrent.futures import ThreadPoolExecutor
def get_one():
    return 1

def test_basic_executor():
    e = ThreadPoolExecutor(max_workers=2)
    a = e.submit(get_one)
    assert a.result() == 1

def test_with_basic_executor():
    with ThreadPoolExecutor(max_workers=2) as e:
        a = e.submit(get_one)
        assert a.result() == 1

def get_slow_one(t=2):
    sleep(t)
    return 1

def test_basic_executor():
    with ThreadPoolExecutor(max_workers=2) as e:
        secToSleep = 2
        a = e.submit(get_slow_one,secToSleep)
        assert not a.done()
        sleep(secToSleep + 1)
        assert a.done()
        assert a.result() == 1

def test_change_non_local():
    x = 0
    def add_x():
        nonlocal x
        x += 1
    assert x == 0
    add_x()
    assert x == 1
# nonlocal restricts scope lookup to just enclosing defs, requires that the names al-
# ready exist there, and allows them to be assigned. Scope lookup does not continue
# on to the global or built-in scopes.

def test_change_non_local_thread():
    x = 0
    def add_x():
        nonlocal x
        x += 1
        return True

    assert x == 0
    e = ThreadPoolExecutor(max_workers=2)
    a = e.submit(add_x)

    assert a.result()           # wait until finished
    assert x == 1


    #+end_src
*** threading
#+begin_src python
from threading import Thread
def test_f():
    def f():
        nonlocal x
        x += 1

    x = 0
    assert x == 0
    t = Thread(target=f)
    t.start()
    assert x == 1

from time import sleep
# from threading import Thread
# from threading import Event
# e = Event()
# def f1():
#     e.wait()
#     print(f'f1 is here')

# def f2():
#     e.wait()
#     print(f'f2 is here')

# def g():
#     sleep(2)
#     print(f'Trigger event')
#     e.set()

# t = Thread(target=f1)
# t.start()

# t2 = Thread(target=f2)
# t2.start()

# t3 = Thread(target=g)
# t3.start()

from random import randrange
from time import sleep
import threading
from threading import Lock
def test_lock():

    lock_for_x = Lock()
    x = 0
    N = 5
    def plus_1():
        nonlocal x
        for i in range(N):
            # sleep(randrange(1,3))
            lock_for_x.acquire()
            x += 1
            print(f'[{threading.get_ident()}] makes it {x}')
            lock_for_x.release()

    t1 = Thread(target=plus_1)
    t2 = Thread(target=plus_1)

    t1.start()
    t2.start()

    t1.join()
    t2.join()
    assert x == 2*N

def test_lock_with():
    lock_for_x = Lock()
    x = 0
    N = 5
    def plus_1():
        nonlocal x
        for i in range(N):
            # sleep(randrange(1,3))
            with lock_for_x:    # acquire, ..., release
                x += 1
                print(f'[{threading.get_ident()}] makes it {x}')

    t1 = Thread(target=plus_1)
    t2 = Thread(target=plus_1)

    t1.start()
    t2.start()

    t1.join()
    t2.join()
    assert x == 2*N

from threading import Timer
def test_timer_ok():
    x = 0
    def f():
        nonlocal x
        x = 1

    t = Timer(3.0,f)
    t.start()
    sleep(4)                    # wait, it should have been finished.
    assert t.finished
    assert x == 1



def test_timer_cancel():
    x = 0
    def f():
        nonlocal x
        x = 1

    t = Timer(3.0,f)
    t.start()
    sleep(1)                    # wait
    t.cancel()                  # stop it
    assert t.finished
    assert x == 0

    #+end_src
*** timer and triggered (simulate a Raft Consensus)
ü¶ú [CAUTION]: If there's a exception, by default, it fails silently.

ü¶ú : Here we assumed everything happens to x is thread safe.
#+begin_src python
import time
from time import sleep
from concurrent.futures import ThreadPoolExecutor
from random import randrange
def test_countdown():
    x = 5
    triggered = False

    def trigger():
        nonlocal triggered
        print(f'üê∏ Triggered')
        triggered = True

    def down_x():
        nonlocal x
        while x > 0:
            print(f'‚ùÑ {x}')
            sleep(1)
            x -= 1
            print(f'After: {x}')
        print(f'‚ùÑ Trigger')
        trigger()

    def add_x():
        nonlocal x
        while x > 0:
            t = randrange(0,8)  # coming in 0-7 secs
            print(f'üê∏ Comming in {t}')
            sleep(t)
            x = 5
            if triggered:
                break
        print(f'üê∏ : bye')

    e = ThreadPoolExecutor(max_workers=3)
    a = e.submit(add_x)
    b = e.submit(down_x)
test_countdown()
#+end_src
*** timer and triggered with lock
#+begin_src python
import time
from time import sleep
from concurrent.futures import ThreadPoolExecutor
from random import randrange
from threading import Lock
def test_countdown():
    x = 5
    lock_for_x  = Lock()
    triggered = False

    def trigger():
        nonlocal triggered
        print(f'üê∏ Triggered')
        triggered = True

    def down_x():
        nonlocal x
        while x > 0:
            print(f'‚ùÑ {x}')
            sleep(1)
            with lock_for_x:
                x -= 1
            print(f'After: {x}')
        print(f'‚ùÑ Trigger')
        trigger()

    def add_x():
        nonlocal x
        while x > 0:
            t = randrange(0,8)  # coming in 0-7 secs
            print(f'üê∏ Comming in {t}')
            sleep(t)
            with lock_for_x:
                x = 5
            if triggered:
                break
        print(f'üê∏ : bye')

    e = ThreadPoolExecutor(max_workers=3)
    a = e.submit(add_x)
    b = e.submit(down_x)
test_countdown()
#+end_src
*** simple deadlock
#+begin_src python
from threading import Thread, Timer, Lock

lock_for_a = Lock()
a = 2
def f():
    with lock_for_a:
        print('Trigger a deadlock')
        g()
def g():
    with lock_for_a:
        print('Hi')
#f() #Trigger a deadlock

def f2():
    with lock_for_a:
        print('Won\'t trigger a deadlock')
        Thread(target=g).start()
f2()
#Won't trigger a deadlock
#Hi
#+end_src
** bytes
#+begin_src python
  # python code demonstrating
  # int to bytes
  str = "Welcome to Geeksforgeeks"
  arr = bytes(str, 'utf-8')
  print(arr)                      # b'Welcome to Geeksforgeeks'

  # python code to demonstrate
  # int to bytes
  number = 12
  result = bytes(number)          # b'\x00\x00\x00\x00\x00 \x00\x00\x00\x00\x00 \x00\x00'
  print(bytes())                  # b''
  l = [1,2,3,4,5]
  bs = bytes(l)              # b'\x01\x02\x03\x04\x05'
  bs.hex()
  b'abc'.hex()               # '616263'
  
  # a = bytearray(bs)
  # len(a)                          # 5
  # hex_string = a.hex()
  # for b in a:
  #     print(b)
#+end_src
** json
#+begin_src python
  import json

def test_dumps():
    o =  {'x': ('b', None, 1.0, 2)}
    s = json.dumps(o)
    assert s == '{"x": ["b", null, 1.0, 2]}'

    s = json.dumps({'4': 5, '6': 7}, sort_keys=True, indent=4)  # indent

def test_loads():
    s = '{"x": ["b", null, 1.0, 2]}'
    o = json.loads(s)
    assert o ==  {'x': ['b', None, 1.0, 2]}

#+end_src
* End

# Local Variables:
# org-what-lang-is-for: "python"
# End:
