** mypy cmd line
#+begin_src bash
  python3 -m pip install mypy
  mypy m.py
  mypy --disallow-untyped-defs m.py
#+end_src
** Basic usage
#+begin_src python
   # For most types, just use the name of the type
  x: int = 1
  x: float = 1.0
  x: bool = True
  x: str = "test"
  x: bytes = b"test"

  # For collections on Python 3.9+, the type of the collection item is in brackets
  x: list[int] = [1]
  x: set[int] = {6, 7}

  # For mappings, we need the types of both keys and values
  x: dict[str, float] = {"field": 2.0}  # Python 3.9+

  # For tuples of fixed size, we specify the types of all the elements
  x: tuple[int, str, float] = (3, "yes", 7.5)  # Python 3.9+

  # For tuples of variable size, we use one type and ellipsis
  x: tuple[int, ...] = (1, 2, 3)  # Python 3.9+

  # On Python 3.8 and earlier, the name of the collection type is
  # capitalized, and the type is imported from the 'typing' module
  from typing import List, Set, Dict, Tuple
  x: List[int] = [1]
  x: Set[int] = {6, 7}
  x: Dict[str, float] = {"field": 2.0}
  x: Tuple[int, str, float] = (3, "yes", 7.5)
  x: Tuple[int, ...] = (1, 2, 3)

  from typing import Union, Optional

  # On Python 3.10+, use the | operator when something could be one of a few types
  x: list[int | str] = [3, 5, "test", "fun"]  # Python 3.10+
  # On earlier versions, use Union
  x: list[Union[int, str]] = [3, 5, "test", "fun"]

  # Use Optional[X] for a value that could be None
  # Optional[X] is the same as X | None or Union[X, None]
  x: Optional[str] = "something" if some_condition() else None
  # Mypy understands a value can't be None in an if-statement
  if x is not None:
      print(x.upper())
  # If a value can never be None due to some invariants, use an assert
  assert x is not None
  print(x.upper())
#+end_src
** More function signature
*** Mark the "void" function
#+begin_src python
def p() -> None:
    print('hello')

a = p()  # Error: "p" does not return a value

def f():
    1 + 'x'  # No static type error (dynamically typed)

def g() -> None:
    1 + 'x'  # Type check error (statically typed)

    #+end_src
*** Mark the arguments
#+begin_src python
def greeting(name: str, excited: bool = False) -> str:
    message = 'Hello, {}'.format(name)
    if excited:
        message += '!!!'
    return message

def stars(*args: int, **kwargs: float) -> None:
    # 'args' has type 'tuple[int, ...]' (a tuple of ints)
    # 'kwargs' has type 'dict[str, float]' (a dict of strs to floats)
    for arg in args:
        print(arg,end=', ')
    print(' ')
    for key, value in kwargs.items():
        print(key, '=>',value)

stars(1,2,3,a=5,b=6)

#+end_src
** Addtional types
*** a list of string (List<string>)
In python > 3.9
#+begin_src python
def greet_all(names: list[str]) -> None:
    for name in names:
        print('Hello ' + name)

names = ["Alice", "Bob", "Charlie"]
ages = [10, 20, 30]

greet_all(names)   # Ok!
greet_all(ages)    # Error due to incompatible types
#+end_src
In python <=3.8
#+begin_src python
from typing import List  # Python 3.8 and earlier

def greet_all(names: List[str]) -> None:
    for name in names:
        print('Hello ' + name)
#+end_src
*** a iterable of string
In > 3.9
#+begin_src python
from collections.abc import Iterable  # or "from typing import Iterable"

def greet_all(names: Iterable[str]) -> None:
    for name in names:
        print('Hello ' + name)
        #+end_src
In <= 3.8       
#+begin_src python
  from typing import Iterable
#+end_src
*** string or int
#+begin_src python
  from typing import Union

  def normalize_id(user_id: Union[int, str]) -> str:
      if isinstance(user_id, int):
          return 'user-{}'.format(100000 + user_id)
      else:
          return user_id
        #+end_src
*** optional string
#+begin_src python
from typing import Optional

def greeting(name: Optional[str] = None) -> str:
    # Optional[str] means the same thing as Union[str, None]
    if name is None:
        name = 'stranger'
    return 'Hello, ' + name

    #+end_src
*** declear global object type, dict
#+begin_src python
# If you're using Python 3.9+
my_global_dict: dict[int, float] = {}
#+end_src
*** 3.10
#+begin_src python
  # Instead of
  # def f(list: List[Union[int, str]], param: Optional[int]) -> Union[float, str]
  def f(list: List[int | str], param: int | None) -> float | str:
      pass

  f([1, "abc"], None)

  # Instead of typing.List[typing.Union[str, int]]
  typing.List[str | int]
  list[str | int]

  # Instead of typing.Dict[str, typing.Union[int, float]]
  typing.Dict[str, int | float]
  dict[str, int | float]
  The existing typing.Union and | syntax should be equivalent.

  int | str == typing.Union[int, str]

  typing.Union[int, int] == int
  int | int == int
#+end_src
** Use stubs for types in a package
"stub" for a pkg is like the header file

To install the stub for a pkg such as <requests>, do
#+begin_src bash
python3 -m pip install types-requests
#+end_src
** Callable
Use ~Callable[[<args>],<return type>]~
#+begin_src python
  from collections.abc import Callable

def feeder(get_next_item: Callable[[], str]) -> None:
    ...  # Body

def async_query(on_success: Callable[[int], None],
                on_error: Callable[[int, Exception], None]) -> None:
    ...  # Body

async def on_update(value: str) -> None:
    ...  # Body

callback: Callable[[str], Awaitable[None]] = on_update
#+end_src
** Cheet sheet
https://mypy.readthedocs.io/en/stable/cheat_sheet_py3.html
** More : Generic T, Callable , etc
https://peps.python.org/pep-0484/
* End

# Local Variables:
# org-what-lang-is-for: "python"
# End:
